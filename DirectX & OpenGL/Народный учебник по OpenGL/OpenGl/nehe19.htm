<!doctype html public "-//w3c//dtd html 3.2 final//ru">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=windows-1251">
<meta name="description"
content="Переводы по OpenGL, трехмерная графика, игры, мультимедия
Translations Russian OpenGL
">
<meta name="keyword"
content="Программирование,игры,3D,трехмерная графика,OpenGL,NeHe">
<meta name="keyword"
content="programming,C,C++,game,graphics">
<title>Урок 19. Машина моделирования частиц с использованием полосок из треугольников</title>
<link rel="stylesheet" href="pmg.css" type="text/css">
</head>

<body bgcolor="#B4B7DC" link="#800080" vlink="#800080">
<!-- SpyLOG v2 f:0210 -->
<script language="javascript">
u="u013.94.spylog.com";d=document;nv=navigator;na=nv.appName;p=1;
bv=Math.round(parseFloat(nv.appVersion)*100);
n=(na.substring(0,2)=="Mi")?0:1;rn=Math.random();z="p="+p+"&rn="+rn+"&tl=0&ls=0&ln=0";y="";
y+="<img src='http://"+u+"/cnt?"+z+
"&r="+escape(d.referrer)+"&pg="+escape(window.location.href)+"' border=0 width=1 height=1 alt='SpyLOG'>";
d.write(y);if(!n) { d.write("<"+"!--"); }//--></script><noscript>
<img src="http://u013.94.spylog.com/cnt?p=1" alt='SpyLOG' border='0' width=1 height=1>
</noscript><script language="javascript1.2"><!--
if(!n) { d.write("--"+">"); }//--></script>
<!-- SpyLOG -->
<script src='nehe.js' language="javascript">
<!--
//-->
</script>

<center>
<div id="top">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
    <tr>
        <td width="20%" align="center" valign="center">
        <img src="nehelogo.jpg" align="left" hspace="0" width="125" height="50" alt="NeHe Tutorials">
        </td>
        <td width="60%" align="center">
	<a href="index.html"
	onmouseover=" return event_over(this,'NeHe Ru.')  "
        onmouseout=" return event_out(this) ">
        <font class="linksbig">
        Народный учебник по OpenGL</font></a><br>
        </td>
        <td width="20%" align="center" valign="center">
        <img src="nehe19.jpg" align="right" hspace="0" width="80" height="60" alt="Урок 19. OpenGL">
        </td>
    </tr>
</table>
</div>

<div id="head">
<p class="head1">
Урок 19. Машина моделирования частиц с использованием полосок из треугольников</p>
</div>
<div id="main" bgcolor="#ADADFF">
<p class="textnoalign" align="left">

<a href="http://nehe.gamedev.net/tutorials/lesson.asp?l=19" target="_blank"
onmouseover=" return event_over(this,this)  "
onmouseout=" return event_out(this) ">
<font class="link"><b>Particle Engine Using Triangle Strips</b></font></a>
<br>
<br>
</p>

<p class=textword>Добро пожаловать на урок 19. Вы многое узнали, и теперь слегка 
  развлечься. Я познакомлю Вас только с одной новой командой в этом уроке... Полоски 
  из треугольников (triangle strip). Это очень удобно, и поможет ускорить ваши 
  программы, когда надо рисовать множество треугольников.<br>
  <br>
</p>
<p class=textword>В этом уроке я обучу Вас, как сделать несложную машину моделирования 
  частиц (Particle Engine). Если Вы поймете, как работает машина моделирования 
  частиц, Вы сможете создавать эффекты огня, дыма, водных фонтанов и так далее, 
  не правда ли хорошее лакомство!<br>
  <br>
</p>
<p class=textword>Я должен, однако предупредить Вас! На сегодняшний день я не 
  написал ни одной машины моделирования частиц. Я знал, что 'знаменитая' машина 
  моделирования частиц очень сложный кусок кода. Я делал попытки ранее, но обычно 
  отказывался от этого после того, как я понимал, что я не смогу управлять всеми 
  точками без того, чтобы не сойти с ума.<br>
  <br>
</p>
<p class=textword>Вы можете мне не поверить, если я Вам скажу, что этот урок был 
  написан на 100% с нуля. Я не заимствовал других идей, и я не имел никакой дополнительной 
  технической информации. Я начал думать о частицах, и внезапно моя голова, наполнилась 
  идеями (мозг включился?). Вместо того чтобы думать о каждой частице, как о пикселе, 
  который был должен следовать от точки 'A' до точки 'B', и делать это или то, 
  я решил, что будет лучше думать о каждой частице как об индивидуальном объекте, 
  реагирующему на окружающую среду вокруг ее. Я дал каждой частице жизнь, случайное 
  старение, цвет, скорость, гравитационное влияние и другое.<br>
  <br>
</p>
<p class=textword>Вскоре я имел готовый проект. Я взглянул на часы, видимо инопланетяне 
  снова забирали меня. Прошло 4 часа! Я помню, что время от времени пил кофе и 
  закрывал глаза, но 4 часа...?<br>
  <br>
</p>
<p class=textword>Поэтому, и хотя эта программа, по-моему, мнению грандиозная, 
  и работает точно, так как я бы хотел, но возможно это не самый правильный способ 
  создать машину моделирования частиц. Я не считаю это очень важным, так как машина 
  моделирования частиц работает хорошо, и я могу использовать ее в моих проектах! 
  Если Вы хотите знать, как точно это делается, то Вам надо потратить множество 
  часов, просматривая сеть, в поисках подходящей информации. Только одно предупреждение. 
  Те фрагменты кода, которые Вы найдете, могут оказаться очень загадочными :).<br>
  <br>
</p>
<p class=textword>Этот урок использует код урока 1. Есть, однако, много нового 
  кода, поэтому я будут переписывать любой раздел кода, который содержит изменения 
  (это будет проще для понимания).<br>
  <br>
</p>
<p class=textword>Используя код урока 1, мы добавим 5 новых строк кода в начало 
  нашей программы. Первая строка (stdio.h) позволит нам читать данные из файлов. 
  Такую же строку, мы добавили и к другим урокам, которые использовали текстуры. 
  Во второй строке задается, сколько мы будем создавать частиц, и отображать на 
  экране. <b>MAX_PARTICLES </b>будет равно любому значению, которое мы зададим. 
  В нашем случае 1000. В третьей строке будет переключаться 'режим радуги' (включен 
  или выключен). Мы установим по умолчанию включенным этот режим. <b>sp</b> и 
  <b>rp</b> - переменные, которые мы будем использовать, чтобы предотвратить автогенерацию 
  повторений нажатия клавиш пробел или ввод (enter), когда они нажаты.<br>
  <br>
</p>
<p class=textpreword>#include &lt;windows.h&gt;  // Заголовочный файл для Windows</p>
<p class=textpreword>#include &lt;stdio.h&gt;    // Заголовочный файл для стандартной 
  библиотеки ввода/вывода(НОВОЕ)</p>
<p class=textpreword>#include &lt;gl\gl.h&gt;    // Заголовочный файл для библиотеки 
  OpenGL32</p>
<p class=textpreword>#include &lt;gl\glu.h&gt;   // Заголовочный файл для библиотеки 
  GLu32 </p>
<p class=textpreword>#include &lt;gl\glaux.h&gt; // Заголовочный файл для библиотеки 
  GLaux<br>
  <br>
  #define MAX_PARTICLES 1000 // Число частиц для создания ( НОВОЕ )<br>
  <br>
  HDC        hDC=NULL;  // Приватный контекст устройства GDI</p>
<p class=textpreword>HGLRC      hRC=NULL;  // Постоянный контекст рендеринга</p>
<p class=textpreword>HWND       hWnd=NULL; // Сохраняет дескриптор окна</p>
<p class=textpreword>HINSTANCE  hInstance; // Сохраняет экземпляр приложения</p>
<p class=textpreword>&nbsp; </p>
<p class=textpreword>bool  keys[256];      // Массив для работы с клавиатурой</p>
<p class=textpreword>bool  active=TRUE;    // Флаг активации окна, по умолчанию 
  = TRUE</p>
<p class=textpreword>bool  fullscreen=TRUE;// Флаг полноэкранного режима</p>
<p class=textpreword><br>
  bool rainbow=true; // Режим радуги? ( НОВОЕ )<br>
  bool sp; // Пробел нажат? ( НОВОЕ )<br>
  bool rp; // Ввод нажат? ( НОВОЕ)<br>
  <br>
</p>
<p class=textword>В следующих 4 строках - разнообразные переменные. Переменная 
  <b>slowdown</b> (торможение) контролирует, как быстро перемещаются частицы. 
  Чем больше ее значение, тем медленнее они двигаются. Чем меньше ее значение, 
  тем быстрее они двигаются. Если значение задано маленькое, частицы будут двигаться 
  слишком быстро! Скорость, с которой частиц перемещаются, будет задавать их траекторию 
  движения по экрану. Более медленные частицы не будут улетать далеко. Запомните 
  это.<br>
  <br>
</p>
<p class=textword>Переменные <b>xspeed</b> и <b>yspeed</b> позволяют нам контролировать 
  направлением хвоста потока частиц. <b>xspeed</b> будет добавляться к текущей 
  скорости частицы по оси X. Если у <b>xspeed</b> - положительное значение, то 
  наша частица будет смещаться направо. Если у <b>xspeed</b> - отрицательное значение, 
  то наша частица будет смещаться налево. Чем выше значение, тем больше это смещение 
  в соответствующем направлении. <b>yspeed</b> работает также, но по оси Y. Причина, 
  по которой я говорю 'БОЛЬШЕ' в заданном направлении означает, что есть и другие 
  коэффициенты, воздействующие на направление траектории частицы. <b>xspeed</b> 
  и <b>yspeed</b> позволяют перемещать частицу в том направлении, в котором мы 
  хотим.<br>
  <br>
</p>
<p class=textword>Последняя переменная <b>zoom</b>. Мы используем эту переменную 
  для панорамирования внутрь и вне нашей сцены. В машине моделирования частиц, 
  это позволяет увеличить размер просмотра, или резко его сократить.<br>
  <br>
</p>
<p class=textpreword>float slowdown=2.0f; // Торможение частиц <br>
  float xspeed; // Основная скорость по X (с клавиатуры изменяется направление 
  хвоста)<br>
  float yspeed; // Основная скорость по Y (с клавиатуры изменяется направление 
  хвоста)<br>
  float zoom=-40.0f; // Масштаб пучка частиц<br>
  <br>
</p>
<p class=textword>Теперь мы задаем еще одну переменную названную <b>loop</b>. 
  Мы будем использовать ее для задания частиц и вывода частиц на экран. <b>col</b> 
  будет использоваться для сохранения цвета, с каким созданы частицы. <b>delay</b> 
  будет использоваться, чтобы циклически повторять цвета в режиме радуги.<br>
  <br>
</p>
<p class=textword>Наконец, мы резервируем память для одной текстуры (текстура 
  частицы). Я решил использовать текстуру вместо точек по нескольким причинам. 
  Наиболее важная причина, что точки замедляют быстродействие и выглядят очень 
  плохо. Во-вторых, текстуры - более крутой способ :). Вы можете использовать 
  квадратную частицу, крошечное изображение вашего лица, изображение звезды, и 
  т.д.  Больше возможностей!<br>
  <br>
</p>
<p class=textpreword>GLuint loop;       // Переменная цикла<br>
  GLuint col;        // Текущий выбранный цвет<br>
  GLuint delay;      // Задержка для эффекта радуги<br>
  GLuint texture[1]; // Память для нашей текстуры<br>
  <br>
</p>
<p class=textword>Отлично, теперь интересный материал. В следующем разделе кода 
  создается структура, которая описывает отдельную частицу. Это то место, где 
  мы даем частице некоторые характеристики. <br>
  <br>
</p>
<p class=textword>Мы начинаем с булевой переменной <b>active</b>. Если эта переменная 
  ИСТИННА, то наша частица жива и летит. Если она равно ЛОЖЬ, то наша частица 
  мертва, или мы выключили ее! В этой программе я не использую <b>active</b>, 
  но ее удобно иметь на всякий случай (прим. переводчика: никогда неизвестно что 
  будет потом, главное следовать определенным принципам).<br>
  <br>
</p>
<p class=textword>Переменные <b>life</b> и <b>fade</b> управляют тем, как долго 
  частица будет отображаться, и насколько яркой она будет, пока жива. Переменная 
  <b>life</b> постепенно уменьшается на значение <b>fade</b>. В этой программе 
  некоторые частицы будут гореть дольше, чем другие.<br>
  <br>
</p>
<p class=textpreword>typedef struct // Структура частицы<br>
  {<br>
    bool active; // Активность (Да/нет)<br>
    float life;  // Жизнь<br>
    float fade;  // Скорость угасания<br>
  <br>
</p>
<p class=textword>Переменные <b>r</b>, <b>g</b> и <b>b</b> задают красную, зеленую 
  и синюю яркости нашей частицы. Чем ближе <b>r</b> к 1.0f, тем более красной 
  будет частица. Если все 3 переменных равны 1.0f, то это создаст белую частицу.<br>
  <br>
</p>
<p class=textpreword>   float r; // Красное значение<br>
    float g; // Зеленное значение<br>
    float b; // Синие значение<br>
  <br>
</p>
<p class=textword>Переменные <b>x</b>, <b>y</b> и <b>z</b> задают, где частица 
  будет отображена на экране. <b>x</b> задает положение нашей частицы по оси X. 
  <b>y</b> задает положение нашей частицы по оси Y, и, наконец, <b>z</b> задает 
  положение нашей частицы по оси Z.<br>
  <br>
</p>
<p class=textpreword>   float x; // X позиция<br>
    float y; // Y позиция<br>
    float z; // Z позиция<br>
  <br>
</p>
<p class=textword>Следующие три переменные важны. Эти три переменные управляют 
  тем, как быстро частица перемещается по заданной оси, и в каком направлении 
  двигается. Если <b>xi</b> имеет отрицательное значение, то наша частица будет 
  двигаться влево. Если положительное, то вправо. Если <b>yi</b> имеет отрицательное 
  значение, то наша частица будет двигаться вниз. Если положительное, то вверх. 
  Наконец, если <b>zi</b> имеет отрицательное значение, то частица будет двигаться 
  вглубь экрана, и, если положительное, то вперед к зрителю. <br>
  <br>
</p>
<p class=textpreword>   float xi; // X направление<br>
    float yi; // Y направление<br>
    float zi; // Z направление<br>
  <br>
</p>
<p class=textword>Наконец, последние 3 переменные! О каждой из этих переменных 
  можно думать как о гравитации. Если <b>xg</b> имеет положительное значение, 
  то нашу частицу будет притягивать вправо. Если отрицательное, то нашу частицу 
  будет притягивать влево. Поэтому, если наша частица перемещает влево (отрицательно) 
  и мы применяем положительную гравитацию, то скорость в итоге замедлится настолько, 
  что наша частица начнет перемещать в противоположном направлении. <b>yg</b> 
  притягивает вверх или вниз, и <b>zg</b> притягивает вперед или назад от зрителя.<br>
  <br>
</p>
<p class=textpreword>   float xg; // X гравитация<br>
    float yg; // Y гравитация<br>
    float zg; // Z гравитация<br>
  <br>
</p>
<p class=textword><b>particles</b> - название нашей структуры.<br>
  <br>
</p>
<p class=textpreword>}<br>
  particles; // Структура Частиц<br>
  <br>
</p>
<p class=textword>Затем мы создаем массив называемый <b>particle</b>. Этот массив 
  имеет размер <b>MAX_PARTICLES</b>. В переводе на русский язык: мы создаем память 
  для хранения 1000 (<b>MAX_PARTICLES</b>) частиц. Это зарезервированная память 
  будет хранить информацию о каждой индивидуальной частице.<br>
  <br>
</p>
<p class=textpreword>particles particle[MAX_PARTICLES]; // Массив частиц (Место для 
  информации о частицах)<br>
  <br>
</p>
<p class=textword>Мы сокращаем код программы, при помощи запоминания наших 12 
  разных цветов в массиве цвета. Для каждого цвета от 0 до 11 мы запоминаем красную, 
  зеленую, и, наконец, синею яркость. В таблице цветов ниже запомнено 12 различных 
  цветов, которые постепенно изменяются от красного до фиолетового цвета.<br>
  <br>
</p>
<p class=textpreword>static GLfloat colors[12][3]= // Цветовая радуга</p>
<p class=textpreword>{<br>
    {1.0f,0.5f,0.5f},{1.0f,0.75f,0.5f},{1.0f,1.0f,0.5f},{0.75f,1.0f,0.5f},<br>
    {0.5f,1.0f,0.5f},{0.5f,1.0f,0.75f},{0.5f,1.0f,1.0f},{0.5f,0.75f,1.0f},<br>
    {0.5f,0.5f,1.0f},{0.75f,0.5f,1.0f},{1.0f,0.5f,1.0f},{1.0f,0.5f,0.75f}<br>
  };<br>
  <br>
  LRESULT  CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM); // Объявление WndProc<br>
  <br>
</p>
<p class=textword>Код загрузки картинки не изменился. <br>
  <br>
</p>
<p class=textpreword>AUX_RGBImageRec *LoadBMP(char *Filename)     // Загрузка 
  картинки</p>
<p class=textpreword>{</p>
<p class=textpreword> FILE *File=NULL;          // Индекс файла</p>
<p class=textpreword>&nbsp;  </p>
<p class=textpreword> if (!Filename)            // Проверка имени файла</p>
<p class=textpreword> {</p>
<p class=textpreword>  return NULL;             // Если нет вернем NULL</p>
<p class=textpreword> }</p>
<p class=textpreword>&nbsp; </p>
<p class=textpreword> File=fopen(Filename,&quot;r&quot;); // Проверим существует 
  ли файл</p>
<p class=textpreword>&nbsp; </p>
<p class=textpreword> if (File)                 // Файл существует?</p>
<p class=textpreword> {</p>
<p class=textpreword>  fclose(File);            // Закрыть файл</p>
<p class=textpreword>  return auxDIBImageLoad(Filename); // Загрузка картинки 
  и вернем на нее указатель</p>
<p class=textpreword> }</p>
<p class=textpreword> return NULL;              // Если загрузка не удалась вернем 
  NULL</p>
<p class=textword>}</p>
<p class=textword>&nbsp;  </p>
<p class=textword>В этом разделе кода загружается картинка (вызов кода выше) и 
  конвертирует его в текстуру. <b>Status</b> используется за тем, чтобы отследить, 
  действительно ли текстура была загружена и создана.<br>
  <br>
</p>
<p class=textpreword>int LoadGLTextures()                      // Загрузка картинки 
  и конвертирование в текстуру</p>
<p class=textpreword>{</p>
<p class=textpreword> int Status=FALSE;                        // Индикатор состояния</p>
<p class=textpreword>&nbsp; </p>
<p class=textpreword> AUX_RGBImageRec *TextureImage[1];        // Создать место 
  для текстуры</p>
<p class=textpreword>&nbsp; </p>
<p class=textpreword> memset(TextureImage,0,sizeof(void *)*1); // Установить указатель 
  в NULL</p>
<p class=textword>&nbsp;  </p>
<p class=textword>Наша текстура загружается кодом, который будет загружать нашу 
  картинку частицы и конвертировать ее в текстуру с линейным фильтром.<br>
  <br>
</p>
<p class=textpreword>if (TextureImage[0]=LoadBMP(&quot;Data/Particle.bmp&quot;)) 
  // Загрузка текстуры частицы</p>
<p class=textpreword>{</p>
<p class=textpreword>  Status=TRUE; // Задать статус в TRUE<br>
    glGenTextures(1, &amp;texture[0]); // Создать одну текстуру<br>
  <br>
    glBindTexture(GL_TEXTURE_2D, texture[0]);<br>
    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);<br>
    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);<br>
    glTexImage2D(GL_TEXTURE_2D, 0, 3, TextureImage[0]-&gt;sizeX, TextureImage[0]-&gt;sizeY,</p>
<p class=textpreword>    0, GL_RGB,   GL_UNSIGNED_BYTE, TextureImage[0]-&gt;data);<br>
  }<br>
  <br>
  if (TextureImage[0])            // Если текстура существует</p>
<p class=textpreword>{</p>
<p class=textpreword> if (TextureImage[0]-&gt;data)     // Если изображение текстуры 
  существует</p>
<p class=textpreword> {</p>
<p class=textpreword>   free(TextureImage[0]-&gt;data); // Освобождение памяти 
  изображения текстуры</p>
<p class=textpreword> }</p>
<p class=textpreword> free(TextureImage[0]);         // Освобождение памяти под 
  структуру</p>
<p class=textpreword>}</p>
<p class=textpreword>&nbsp; </p>
<p class=textpreword>  return Status;        // Возвращаем статус</p>
<p class=textpreword>}<br>
  <br>
</p>
<p class=textword>Единственное изменение, которое я сделал в коде изменения размера, 
  было увеличение области просмотра. Вместо 100.0f, мы можем теперь рассматривать 
  частицы на 200.0f единиц в глубине экрана.<br>
  <br>
</p>
<p class=textpreword>// Изменение размеров и инициализация окна GL</p>
<p class=textpreword>GLvoid ReSizeGLScene(GLsizei width, GLsizei height) <br>
  {<br>
    if (height==0) // Предотвращение деления на ноль, если окно слишком мало<br>
    {<br>
      height=1; // Сделать высоту равной единице<br>
    }</p>
<p class=textpreword><br>
    //Сброс текущей области вывода и перспективных преобразований
  <br>    glViewport(0, 0, width, height);<br>
  <br>
    glMatrixMode(GL_PROJECTION); // Выбор матрицы проекций<br>
    glLoadIdentity(); // Сброс матрицы проекции<br>
  <br>
    // Вычисление соотношения геометрических размеров для окна<br>
    gluPerspective(45.0f,(GLfloat)width/(GLfloat)height,0.1f,200.0f); // ( МОДИФИЦИРОВАНО 
  )<br>
  <br>
    glMatrixMode(GL_MODELVIEW); // Выбор матрицы просмотра модели<br>
    glLoadIdentity(); // Сброс матрицы просмотра модели<br>
  }<br>
  <br>
</p>
<p class=textword>Если Вы используете код урока 1, замените его на код ниже. Я 
  добавил этот код для загрузки  нашей текстуры и включения смешивания для наших 
  частиц. <br>
  <br>
</p>
<p class=textpreword>int InitGL(GLvoid)       // Все начальные настройки OpenGL 
  здесь<br>
  {<br>
    if (!LoadGLTextures()) // Переход на процедуру загрузки текстуры<br>
    {<br>
      return FALSE;        // Если текстура не загружена возвращаем FALSE<br>
    }<br>
  <br>
</p>
<p class=textword>Мы разрешаем плавное затенение, очищаем фон черным цветом, запрещаем 
  тест глубины, разрешаем смешивание и наложение текстуры. После разрешения наложения 
  текстуры мы выбираем нашу текстуру частицы.<br>
  <br>
</p>
<p class=textpreword>  glShadeModel(GL_SMOOTH);    // Разрешить плавное затенение</p>
<p class=textpreword>  glClearColor(0.0f, 0.0f, 0.0f, 0.0f); // Черный фон</p>
<p class=textpreword>  glClearDepth(1.0f);         // Установка буфера глубины</p>
<p class=textpreword>  glDisable(GL_DEPTH_TEST);   // Запрещение теста глубины</p>
<p class=textpreword>  glEnable(GL_BLEND);         // Разрешаем смешивание<br>
    glBlendFunc(GL_SRC_ALPHA,GL_ONE); // Тип смешивания</p>
<p class=textpreword>  // Улучшенные вычисления перспективы <br>
    glHint(GL_PERSPECTIVE_CORRECTION_HINT,GL_NICEST);<br>
    glHint(GL_POINT_SMOOTH_HINT,GL_NICEST);  // Улучшенные точечное смешение <br>
    glEnable(GL_TEXTURE_2D);                 // Разрешение наложения текстуры 
  <br>
    glBindTexture(GL_TEXTURE_2D,texture[0]); // Выбор нашей текстуры <br>
  <br>
</p>
<p class=textword>В коде ниже инициализируется каждая из частиц. Вначале мы активизируем 
  каждую частицу. Если частица - не активна, то она не будет появляться на экране, 
  независимо оттого, сколько жизни у нее осталось.<br>
  <br>
</p>
<p class=textword>После того, как мы сделали частицу активной, мы даем ей жизнь. 
  Я сомневаюсь, что тот способ, с помощью которого я задаю жизнь, и угасание частицы, 
  это самый лучший способ, но повторюсь еще раз, что это отлично работает! Полная 
  жизнь - 1.0f. Это также дает частице полную яркость.<br>
  <br>
</p>
<p class=textpreword>for (loop=0;loop&lt;MAX_PARTICLES;loop++) // Инициализация всех 
  частиц<br>
  {<br>
    particle[loop].active=true; // Сделать все частицы активными<br>
    particle[loop].life=1.0f;   // Сделать все частицы с полной жизнью <br>
  <br>
</p>
<p class=textword>Мы задаем, как быстро частица угасает, при помощи присвоения 
  <b>fade</b> случайного значения. Переменная <b>life</b> будет уменьшаться на 
  значение <b>fade</b>, каждый раз, после того как частица будет отображена. Случайное 
  значение будет от 0 до 99. Его мы делим его на 1000, поэтому мы получим очень 
  маленькое значение с плавающей запятой. В завершении мы добавим 0.003 к конечному 
  результату так, чтобы скорость угасания никогда не равнялось 0.<br>
  <br>
</p>
<p class=textpreword>
  //Случайная скорость угасания<br>
  particle[loop].fade=float(rand()%100)/1000.0f+0.003f;</p>
<p class=textword>&nbsp;  </p>
<p class=textword>Теперь, когда наша частица активна, и мы дали ей жизнь, пришло 
  время задать ей цвет. Вначале, мы хотим, чтобы все частицы были разным цветом. 
  Поэтому я, делаю каждую частицу одним из 12 цветов, которые мы поместили в нашу 
  таблицу цветов вначале этой программы. Математика проста. Мы берем нашу переменную 
  <b>loop</b> и умножаем ее на число цветов в нашей таблице цвета, и делим на 
  максимальное число частиц (<b>MAX_PARTICLES</b>). Это препятствует тому, что 
  заключительное значение цвета будет больше, чем наш максимальное число цветов 
  (12).<br>
  <br>
</p>
<p class=textword>Вот пример: 900 * (12/900) =12. 1000 * (12/1000) =12, и т.д.<br>
  <br>
</p>
<p class=textpreword>  particle[loop].r=colors[loop*(12/MAX_PARTICLES)][0]; // Выбор 
  красного цвета радуги<br>
    particle[loop].g=colors[loop*(12/MAX_PARTICLES)][1]; // Выбор зеленного цвета 
  радуги<br>
    particle[loop].b=colors[loop*(12/MAX_PARTICLES)][2]; // Выбор синего цвета 
  радуги<br>
  <br>
</p>
<p class=textword>Теперь мы зададим направление, в котором каждая частица двигается, 
  наряду со скоростью. Мы умножаем результат на 10.0f, чтобы создать впечатление 
  взрыва, когда программа запускается.<br>
  <br>
</p>
<p class=textword>Мы начинаем с положительного или отрицательного случайного значения. 
  Это значение будет использоваться для перемещения частицы в случайном направлении 
  со случайной скоростью.<br>
  <br>
</p>
<p class=textpreword>  particle[loop].xi=float((rand()%50)-26.0f)*10.0f; // Случайная 
  скорость по оси X <br>
    particle[loop].yi=float((rand()%50)-25.0f)*10.0f; // Случайная скорость по 
  оси Y<br>
    particle[loop].zi=float((rand()%50)-25.0f)*10.0f; // Случайная скорость по 
  оси Z<br>
  <br>
</p>
<p class=textword>Наконец, мы задаем величину гравитации, которая воздействует 
  на каждую частицу. В отличие от реальной гравитации, под действием которой все 
  предметы падают вниз, наша гравитация сможет смещать частицы вниз, влево, вправо, 
  вперед или назад (прим. переводчика: скорее всего это электромагнитное поле, 
  а не гравитация). Вначале мы зададим гравитацию в полсилы, которая притягивает 
  вниз. Чтобы сделать это, мы устанавливаем <b>xg</b> в 0.0f. Т.е. нет перемещения 
  влево или вправо по плоскости X. Мы устанавливаем <b>yg</b> в -0.8f. Это создает 
  притяжение вниз в полсилы. Если значение положительное, то притяжение вверх. 
  Мы не хотим, чтобы частицы притягивались к нам или от нас, поэтому мы установим 
  <b>zg</b> в 0.0f.<br>
  <br>
</p>
<p class=textpreword>  particle[loop].xg=0.0f;  // Зададим горизонтальное притяжение 
  в ноль <br>
    particle[loop].yg=-0.8f; // Зададим вертикальное притяжение вниз <br>
    particle[loop].zg=0.0f;  // зададим притяжение по оси Z в ноль <br>
  }<br>
  return TRUE; // Инициализация завершена OK<br>
  }<br>
  <br>
</p>
<p class=textword>Теперь интересный материал. В следующем разделе кода мы выводим 
  частицу, проверяем гравитацию, и т.д. Очень важно, чтобы Вы поняли, что происходит 
  там, поэтому, пожалуйста, читайте тщательно :).<br>
  <br>
</p>
<p class=textword>Мы сбрасываем матрицу просмотра модели только однажды. Мы позиционируем 
  частицы, используя команду <b>glVertex3</b><b>f()</b> вместо использования перемещения 
  их, при таком способе вывода частиц мы не изменяем матрицу просмотра модели 
  при выводе наших частиц. <br>
  <br>
</p>
<p class=textpreword>int DrawGLScene(GLvoid) // Здесь мы все рисуем <br>
  {<br>
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // Очистка экрана и буфера 
  глубины</p>
<p class=textpreword>  glLoadIdentity(); // Сброс матрицы просмотра модели<br>
  <br>
</p>
<p class=textword>Мы начинаем наш вывод с цикла. Этот цикл обновит каждую из наших 
  частиц. <br>
  <br>
</p>
<p class=textpreword>  for (loop=0;loop&lt;MAX_PARTICLES;loop++) // Цикл по всем 
  частицам <br>
    {<br>
  <br>
</p>
<p class=textword>Вначале мы проверим, активна ли наша частица. Если она не активна, 
  то ее не надо модифицировать. В этой программе они активны всегда. Но в вашей 
  программе, Вы сможете захотеть сделать некоторые частицы неактивными.<br>
  <br>
</p>
<p class=textpreword>    if (particle[loop].active) // Если частицы не активны <br>
      {<br>
  <br>
</p>
<p class=textword>Следующие три переменные <b>x</b>, <b>y</b> и <b>z</b> - временные 
  переменные, которые мы будем использовать, чтобы запомнить позицию частицы по 
  x, y и z. Отмечу, что мы добавляем <b>zoom</b> к позиции по <b>z,</b> так как 
  наша сцена смещена в экран на значение <b>zoom</b>. <b>particle[</b><b>loop].</b><b>x</b> 
  - это наша позиция по x для любой частицы, которую мы выводим в цикле. <b>particle[</b><b>loop].</b><b>y</b> 
  - это наша позиция по y для нашей частицы, и <b>particle[</b><b>loop].</b><b>z</b> 
  - это наша позиция по z.<br>
  <br>
</p>
<p class=textpreword>      float x=particle[loop].x; // Захватим позицию X нашей 
  частицы <br>
        float y=particle[loop].y; // Захватим позицию Н нашей частицы<br>
        float z=particle[loop].z+zoom; // Позиция частицы по Z + Zoom<br>
  <br>
</p>
<p class=textword>Теперь, когда мы имеем позицию частицы, мы можем закрасить частицу. 
  <b>particle[</b><b>loop].</b><b>r</b> - это красная яркость частицы, <b>particle[</b><b>loop].</b><b>g</b> 
  – это зеленая яркость, и <b>particle[</b><b>loop].</b><b>b</b> – это синяя яркость. 
  Напомню, что я использую жизнь частицы (<b>life</b>) для альфа значения. По 
  мере того, как частица умирает, она становится все более и более прозрачной, 
  пока она, в конечном счете, не исчезнет. Именно поэтому, жизнь частиц никогда 
  не должна быть больше чем 1.0f. Если Вы хотите, чтобы частицы горели более долго, 
  пробуйте уменьшить скорость угасания так, чтобы частица не так быстро исчезла.<br>
  <br>
</p>
<p class=textpreword>      // Вывод частицы, используя наши RGB значения, угасание 
  частицы согласно её жизни <br>
        glColor4f(particle[loop].r,particle[loop].g,particle[loop].b,particle[loop].life);<br>
  <br>
</p>
<p class=textword>Мы задали позицию частицы и цвет. Все, что мы должны теперь 
  сделать - вывести нашу частицу. Вместо использования текстурированного четырехугольника, 
  я решил использовать текстурированную полоску из треугольников, чтобы немного 
  ускорить программу. Некоторые 3D платы могут выводить треугольники намного быстрее 
  чем, они могут выводить четырехугольники. Некоторые 3D платы конвертируют четырехугольник 
  в два треугольника за Вас, но некоторые платы этого не делают. Поэтому мы сделаем 
  эту работу сами. Мы начинаемся с того, что сообщаем OpenGL, что мы хотим вывести 
  полоску из треугольников.<br>
  <br>
</p>
<p class=textpreword>      glBegin(GL_TRIANGLE_STRIP); // Построение четырехугольника 
  из треугольной полоски <br>
  <br>
</p>
<p class=textword>Цитата непосредственно из красной книги (OpenGL Red Book): полоска 
  из треугольников рисуется как ряд треугольников (трехсторонних полигонов) используя 
  вершины V<sub>0</sub>, V<sub>1</sub>, V<sub>2</sub>, затем V<sub>2</sub>, V<sub>1</sub>, 
  V<sub>3</sub> (обратите внимание на порядок), затем V<sub>2</sub>, V<sub>3</sub>, 
  V<sub>4</sub>, и так далее. Порядок должен гарантировать, что все треугольники 
  будут выведены с той же самой ориентацией так, чтобы полоска могла правильно 
  формировать часть поверхности. Соблюдение ориентации важно для некоторых операций, 
  типа отсечения. Должны быть, по крайней мере, 3 точки, чтобы было что-то выведено.<br>
  <br>
</p>
<p class=textword align=center style='text-align:center'>
<img width=128 height=128 src="nehe19-1.jpg"> <br>
<i>Рисунок 1. Полоска из двух треугольников</i></p>
<p class=textword>&nbsp; </p>
<p class=textword>Поэтому первый треугольник выведен, используя вершины 0, 1 и 
  2. Если Вы посмотрите на рисунок 1, Вы увидите, что точки вершин 0, 1 и 2 действительно 
  составляют первый треугольник (верхняя правая, верхняя левая, нижняя правая). 
  Второй треугольник выведен, используя вершины 2, 1 и 3. Снова, если Вы посмотрите 
  на рисунок 1, вершины 2, 1 и 3 создают второй треугольник (нижняя правая, верхняя 
  левая, нижняя правая). Заметьте, что оба треугольника выведены с тем же самым 
  порядком обхода (против часовой стрелки). Я видел несколько сайтов, на которых 
  заявлялось, что каждый второй треугольник должен быть в противоположном направлении. 
  Это<u> не так</u>. OpenGL будет менять вершины, чтобы гарантировать, что все 
  треугольники выведены тем же самым способом!<br>
  <br>
</p>
<p class=textword>Есть две хорошие причины, для того чтобы использовать полоски 
  из треугольников. Во-первых, после определения первых трех вершин начального 
  треугольника, Вы должны только определять одну единственную точку для каждого 
  другого дополнительного треугольника. Эта точка будет объединена с 2 предыдущим 
  вершинами для создания треугольника. Во-вторых, сокращая количество данных, 
  необходимых для создания треугольников ваша программа будет работать быстрее, 
  и количество кода или данных, требуемых для вывода объекта резко сократиться.<br>
  <br>
</p>
<p class=textword>Примечание: число треугольников, которые Вы видите на экране, 
  будет равно числу вершин, которые Вы зададите минус 2. В коде ниже мы имеем 
  4 вершины, и мы видим два треугольника.<br>
  <br>
</p>
<p class=textpreword>      glTexCoord2d(1,1); glVertex3f(x+0.5f,y+0.5f,z); // Верхняя 
  правая<br>
        glTexCoord2d(0,1); glVertex3f(x-0.5f,y+0.5f,z); // Верхняя левая<br>
        glTexCoord2d(1,0); glVertex3f(x+0.5f,y-0.5f,z); // Нижняя правая <br>
        glTexCoord2d(0,0); glVertex3f(x-0.5f,y-0.5f,z); // Нижняя левая<br>
  <br>
</p>
<p class=textword>Наконец мы сообщаем OpenGL, что мы завершили вывод нашей полоски 
  из треугольников.<br>
  <br>
</p>
<p class=textpreword>      glEnd(); // Завершение построения полоски треугольников 
  <br>
  <br>
</p>
<p class=textword>Теперь мы можем переместить частицу. Математически это может 
  выглядеть несколько странно, но довольно просто. Сначала мы берем текущую позицию 
  x частицы. Затем мы добавляем значение смещения частицы по x, деленной на <b>slowdown</b>/1000. 
  Поэтому, если наша частица была в центре экрана на оси X (0), наша переменная 
  смещения (<b>xi</b>) для оси X равна +10 (смещение вправо от нас) и <b>slowdown</b> 
  было равно 1, мы сместимся направо на 10/(1*1000), или на 0.01f. Если мы увеличим 
  <b>slowdown</b> на 2, мы сместимся только на 0.005f. Буду надеяться, что это 
  поможет Вам понять, как работает замедление (<b>slowdown</b>).<br>
  <br>
</p>
<p class=textword>Это также объясняет, почему умножение начальных значений на 
  10.0f заставляет пиксели перемещаться намного быстрее, создавая эффект взрыва.<br>
  <br>
</p>
<p class=textword>Мы используем ту же самую формулу для осей y и z, для того чтобы 
  переместить частицу по экрану.<br>
  <br>
</p>
<p class=textpreword>      // Передвижение по оси X на скорость по X</p>
<p class=textpreword>      particle[loop].x+=particle[loop].xi/(slowdown*1000); <br>
        // Передвижение по оси Y на скорость по Y</p>
<p class=textpreword>      particle[loop].y+=particle[loop].yi/(slowdown*1000);<br>
        // Передвижение по оси Z на скорость по Z</p>
<p class=textpreword>      particle[loop].z+=particle[loop].zi/(slowdown*1000); <br>
  <br>
</p>
<p class=textword>После того, как мы вычислили перемещение частицы, следующее, 
  что мы должны сделать, это учесть гравитацию или сопротивление. В первой строке 
  ниже, мы делаем это, при помощи добавления нашего сопротивления (<b>xg</b>) 
  к скорости перемещения (<b>xi</b>).<br>
  <br>
</p>
<p class=textword>Предположим, что скорость перемещения равна 10, а сопротивление 
  равно 1. Первый раз, когда частица выводиться на экран, сопротивление воздействует 
  на нее. Во второй раз, когда она выводится, сопротивление будет действовать, 
  и скорость перемещения понизится от 10 до 9. Это заставит частицу немного замедлится. 
  В третий раз, когда частица выводиться, сопротивление действует снова, и скорость 
  перемещения понизится до 8. Если бы частица горела больше чем 10 перерисовок, 
  то она будет в итоге перемещаться в противоположном направлении, потому что 
  скорость перемещения станет отрицательным значением.<br>
  <br>
</p>
<p class=textword>Сопротивление применяется к скорости перемещения по y и z, так 
  же, как и по x.<br>
  <br>
</p>
<p class=textpreword>      particle[loop].xi+=particle[loop].xg; // Притяжение по 
  X для этой записи <br>
        particle[loop].yi+=particle[loop].yg; // Притяжение по Y для этой записи<br>
        particle[loop].zi+=particle[loop].zg; // Притяжение по Z для этой записи<br>
  <br>
</p>
<p class=textword>В следующей строке забирается часть жизни от частицы. Если бы 
  мы не делали этого, то частица бы никогда не сгорела бы. Мы берем текущую жизнь 
  частицы и вычитаем значение угасания для этой частицы. Каждая частица имеет 
  свое значение угасания, поэтому они будут гореть с различными скоростями.<br>
  <br>
</p>
<p class=textpreword>      particle[loop].life-=particle[loop].fade; // Уменьшить 
  жизнь частицы на ‘угасание’<br>
  <br>
</p>
<p class=textword>Теперь мы проверим, жива ли частица, после того как мы изменили 
  ее жизнь.<br>
  <br>
</p>
<p class=textpreword>      if (particle[loop].life&lt;0.0f) // Если частица погасла 
  <br>
        {<br>
  <br>
</p>
<p class=textword>Если частица мертва (сгорела), мы оживим ее. Мы сделаем это, 
  задав ей полную жизнь и новую скорость угасания.<br>
  <br>
</p>
<p class=textpreword>        particle[loop].life=1.0f; // Дать новую жизнь<br>
          // Случайное значение угасания<br>
          particle[loop].fade=float(rand()%100)/1000.0f+0.003f;<br>
  <br>
</p>
<p class=textword>Мы также сделаем сброс позиций частицы в центр экрана. Мы делаем 
  это, при помощи сброса позиций x, y и z частицы в ноль.<br>
  <br>
</p>
<p class=textpreword>        particle[loop].x=0.0f; // На центр оси X <br>
          particle[loop].y=0.0f; // На центр оси Y<br>
          particle[loop].z=0.0f; // На центр оси Z<br>
  <br>
</p>
<p class=textword>После того, как частица была сброшена в центр экрана, мы задаем 
  ей новую скорость перемещения / направления. Отмечу, что я увеличил максимальную 
  и минимальную скорость, с которой частица может двигаться со случайного значения 
  в диапазоне 50 до диапазона 60, но на этот раз, мы не собирается умножать скорость 
  перемещения на 10. Мы не хотим взрыва на этот раз, мы хотим иметь более медленно 
  перемещающиеся частицы.<br>
  <br>
</p>
<p class=textword>Также заметьте, что я добавил <b>xspeed</b> к скорости перемещения 
  по оси X, и <b>yspeed</b> к скорости перемещения по оси Y. Это позволит нам 
  позже контролировать, в каком направлении двигаются частицы.<br>
  <br>
</p>
<p class=textpreword>        particle[loop].xi=xspeed+float((rand()%60)-32.0f);//Скорость и направление по оси X<br>
          particle[loop].yi=yspeed+float((rand()%60)-30.0f);//Скорость и направление по оси Y<br>
          particle[loop].zi=float((rand()%60)-30.0f);       //Скорость и направление по оси Z<br>
  <br>
</p>
<p class=textword>Наконец мы назначаем частице новый цвет. В переменной <b>col</b> 
  содержится число от 0 до 11 (12 цветов). Мы используем эту переменную для извлечения 
  красной, зеленой и синей яркостей из нашей таблицы цветов, которую мы сделали 
  в начале программы. В первой строке ниже задается красная яркость (r) согласно 
  значению красного, сохраненного в <b>colors[</b><b>col][0]</b>. Поэтому, если 
  бы <b>col</b> равен 0, красная яркость равна 1.0f. Зеленые и синие значения 
  получаются таким же способом.<br>
  <br>
</p>
<p class=textword>Если Вы не поняли, как я получил значение 1.0f для красной яркости, 
  если <b>col</b> - 0, я объясню это немного более подробно. Смотрите в начало 
  программы. Найдите строку: <b>static GLfloat colors[12][3]</b>. Запомните, что 
  есть 12 групп по 3 числа. Первые три числа - красная яркость. Второе значение 
  - зеленая яркость, и третье значение - синяя яркость. [0], [1] и [2] ниже являются 
  1-ым, 2-ым и 3-ьим значениями, которые я только что упомянул. Если <b>col</b> 
  равен 0, то мы хотим взглянуть на первую группу. 11 – последняя группа (12-ый 
  цвет).<br>
  <br>
</p>
<p class=textpreword>        particle[loop].r=colors[col][0]; // Выбор красного из 
  таблицы цветов<br>
          particle[loop].g=colors[col][1]; // Выбор зеленого из таблицы цветов<br>
          particle[loop].b=colors[col][2]; // Выбор синего из таблицы цветов<br>
        }<br>
  <br>
</p>
<p class=textword>Строка ниже контролирует, насколько гравитация будет притягивать 
  вверх. При помощи нажатия клавиши 8 на цифровой клавиатуре, мы увеличиваем переменную 
  <b>yg</b> (y гравитация). Это вызовет притяжение вверх. Этот код расположен 
  здесь, потому что это сделает нашу жизнь проще, гравитация будет назначена ко 
  всем нашим частицам с помощью цикла. Если бы этот код был бы вне цикла, мы должны 
  были бы создать другой цикл, чтобы проделать ту же самую работу, поэтому мы 
  можем также сделать это прямо здесь.<br>
  <br>
</p>
<p class=textpreword>      // Если клавиша 8 на цифровой клавиатуре нажата и гравитация 
  меньше чем 1.5</p>
<p class=textpreword>      // тогда увеличим притяжение вверх<br>
        if (keys[VK_NUMPAD8] &amp;&amp; (particle[loop].yg&lt;1.5f)) particle[loop].yg+=0.01f;<br>
  <br>
</p>
<p class=textword>Эта строка создает точно противоположный эффект. При помощи 
  нажатия 2 на цифровой клавиатуре мы уменьшаем <b>yg</b>, создавая более сильное 
  притяжение вниз.<br>
  <br>
</p>
<p class=textpreword>      // Если клавиша 2 на цифровой клавиатуре нажата и гравитация 
  больше чем -1.5</p>
<p class=textpreword>      // тогда увеличим притяжение вниз<br>
        if (keys[VK_NUMPAD2] &amp;&amp; (particle[loop].yg&gt;-1.5f)) particle[loop].yg-=0.01f;<br>
  <br>
</p>
<p class=textword>Теперь мы модифицируем притяжение вправо. Если клавиша 6 на 
  цифровой клавиатуре нажата, то мы увеличиваем притяжение вправо.<br>
  <br>
</p>
<p class=textpreword>      // Если клавиша 6 на цифровой клавиатуре нажата и гравитация 
  меньше чем 1.5</p>
<p class=textpreword>      // тогда увеличим притяжение вправо<br>
        if (keys[VK_NUMPAD6] &amp;&amp; (particle[loop].xg&lt;1.5f)) particle[loop].xg+=0.01f;<br>
  <br>
</p>
<p class=textword>Наконец, если клавиша 4  на цифровой клавиатуре нажата, то наша 
  частица будет больше притягиваться влево. Эти клавиши позволяют получить некоторые 
  действительно интересные результаты. Например, Вы сможете сделать поток частиц, 
  стреляющих прямо в воздух. Добавляя немного притяжения вниз, Вы сможете превратить 
  поток частиц в фонтан воды!<br>
  <br>
</p>
<p class=textpreword>      // Если клавиша 4 на цифровой клавиатуре нажата и гравитация 
  больше чем -1.5</p>
<p class=textpreword>      // тогда увеличим притяжение влево<br>
        if (keys[VK_NUMPAD4] &amp;&amp; (particle[loop].xg&gt;-1.5f)) particle[loop].xg-=0.01f;<br>
  <br>
</p>
<p class=textword>Я добавил этот небольшой код только для развлечения. Мой брат 
  думает, что взрыв интересный эффект :). При помощи нажатия клавиши табуляции 
  все частицы будут отброшены назад к центру экрана. Скорость перемещения частиц 
  будет еще раз умножена на 10, создавая большой взрыв частиц. После того, как 
  частицы взрыва постепенно исчезнут, появиться предыдущий столб частиц.<br>
  <br>
</p>
<p class=textpreword>      if (keys[VK_TAB]) // Клавиша табуляции вызывает взрыв 
  <br>
        {<br>
          particle[loop].x=0.0f; // Центр по оси X<br>
          particle[loop].y=0.0f; // Центр по оси Y<br>
          particle[loop].z=0.0f; // Центр по оси Z<br>
          particle[loop].xi=float((rand()%50)-26.0f)*10.0f; // Случайная скорость 
  по оси X <br>
          particle[loop].yi=float((rand()%50)-25.0f)*10.0f; // Случайная скорость 
  по оси Y<br>
          particle[loop].zi=float((rand()%50)-25.0f)*10.0f; // Случайная скорость 
  по оси Z<br>
        }<br>
      }<br>
    }<br>
    return TRUE; // Все OK<br>
  }<br>
  <br>
</p>
<p class=textword>Код в <b>KillGLWindow()</b>, <b>CreateGLWindow()</b> и <b>WndProc()</b> 
  не изменился, поэтому мы перейдем к <b>WinMain()</b>. Я повторю весь этот раздел 
  кода, чтобы сделать просмотр кода проще.<br>
  <br>
</p>
<p class=textpreword>int WINAPI WinMain(</p>
<p class=textpreword>          HINSTANCE hInstance,     // Экземпляр</p>
<p class=textpreword>          HINSTANCE hPrevInstance, // Предыдущий экземпляр</p>
<p class=textpreword>          LPSTR     lpCmdLine,     // Параметры командной 
  строки</p>
<p class=textpreword>          int       nCmdShow)      // Показать состояние 
  окна</p>
<p class=textpreword>{</p>
<p class=textpreword>  MSG  msg;        // Структура сообщения окна</p>
<p class=textpreword>  BOOL done=FALSE; // Булевская переменная выхода из цикла</p>
<p class=textpreword>&nbsp; </p>
<p class=textpreword>  // Запросим пользователя какой режим отображения он предпочитает</p>
<p class=textpreword>  if (MessageBox(NULL,&quot;Would You Like To Run In Fullscreen 
  Mode?&quot;,</p>
<p class=textpreword>      &quot;Start FullScreen?&quot;,MB_YESNO|MB_ICONQUESTION)==IDNO)</p>
<p class=textpreword>  {</p>
<p class=textpreword>    fullscreen=FALSE;              // Оконный режим</p>
<p class=textpreword>  }</p>
<p class=textpreword>&nbsp;  </p>
<p class=textpreword>  // Создадим наше окно OpenGL</p>
<p class=textpreword>  if (!CreateGLWindow(&quot;NeHe's Particle Tutorial&quot;,640,480,16,fullscreen))</p>
<p class=textpreword>  {</p>
<p class=textpreword>    return 0;                  // Выходим если окно не было 
  создано</p>
<p class=textpreword>  }</p>
<p class=textword>&nbsp;  </p>
<p class=textword>Далее наше первое изменение в <b>WinMain()</b>. Я добавил код, 
  который проверяет, в каком режиме пользователь решил запустить программу - в 
  полноэкранном режиме или в окне. Если  используется полноэкранный режим, я изменяю 
  переменную <b>slowdown</b> на 1.0f вместо 2.0f. Вы можете опустить этот небольшой 
  код, если Вы хотите. Я добавил этот код, чтобы ускорить полноэкранный режим 
  на моем 3dfx (потому что при этом выполнение программы намного медленнее, чем 
  в режиме окна по некоторым причинам).<br>
  <br>
</p>
<p class=textpreword>  if (fullscreen)  // Полноэкранный режим ( ДОБАВЛЕНО )<br>
    {<br>
      slowdown=1.0f; // Скорость частиц (для 3dfx) ( ДОБАВЛЕНО )<br>
    }<br>
  <br>
</p>
<p class=textpreword>  while (!done) // Цикл, который продолжается пока done=FALSE</p>
<p class=textpreword>  {</p>
<p class=textpreword>    if (PeekMessage(&amp;msg,NULL,0,0,PM_REMOVE)) // Есть 
  ожидаемое сообщение?</p>
<p class=textpreword>    {</p>
<p class=textpreword>      if (msg.message==WM_QUIT) // Мы получили сообщение 
  о выходе?</p>
<p class=textpreword>      {</p>
<p class=textpreword>        done=TRUE; // Если так done=TRUE</p>
<p class=textpreword>      }</p>
<p class=textpreword>      else // Если нет, продолжаем работать с сообщениями 
  окна</p>
<p class=textpreword>      {</p>
<p class=textpreword>        TranslateMessage(&amp;msg); // Переводим сообщение</p>
<p class=textpreword>        DispatchMessage(&amp;msg);  // Отсылаем сообщение</p>
<p class=textpreword>      }</p>
<p class=textpreword>    }</p>
<p class=textpreword>    else // Если сообщений нет</p>
<p class=textpreword>    {</p>
<p class=textpreword>      // Рисуем сцену. Ожидаем нажатия кнопки ESC и сообщения 
  о выходе от DrawGLScene()</p>
<p class=textpreword>      // Активно?  Было получено сообщение о выходе?</p>
<p class=textpreword>      if ((active &amp;&amp; !DrawGLScene()) || keys[VK_ESCAPE])</p>
<p class=textpreword>      {</p>
<p class=textpreword>        done=TRUE; // ESC или DrawGLScene просигналили &quot;выход&quot;</p>
<p class=textpreword>      }</p>
<p class=textpreword>      else // Не время выходить, обновляем экран</p>
<p class=textpreword>      {</p>
<p class=textpreword>        SwapBuffers(hDC); // Переключаем буферы (Двойная 
  буфферизация)</p>
<p class=textword>&nbsp; </p>
<p class=textword>Я немного попотел со следующим куском кода. Обычно я не включаю 
  все в одну строку, и это делает просмотр кода немного яснее :).<br>
  <br>
</p>
<p class=textword>В строке ниже проверяется, нажата ли клавиша ‘+’ на цифровой 
  клавиатуре. Если она нажата, и <b>slowdown</b> больше чем 1.0f, то мы уменьшаем 
  <b>slowdown</b> на 0.01f. Это заставит частицы двигаться быстрее. Вспомните, 
  что я говорил выше о торможении и как оно воздействует на скорость, с которой 
  частица перемещается.<br>
  <br>
</p>
<p class=textpreword>        if (keys[VK_ADD] &amp;&amp; (slowdown&gt;1.0f)) slowdown-=0.01f;//Скорость частицы увеличилась<br>
  <br>
</p>
<p class=textword>В этой строке проверяется, нажата ли клавиша ‘-‘ на цифровой 
  клавиатуре. Если она нажата, и <b>slowdown</b> меньше чем 4.0f, то мы увеличиваем 
  <b>slowdown</b>. Это заставляет частицы двигаться медленнее. Я выставил предел 
  в 4.0f, потому что я не хочу, чтобы они двигались очень медленно. Вы можете 
  изменить минимальные и максимальные скорости, на какие Вы хотите :).<br>
  <br>
</p>
<p class=textpreword>        if (keys[VK_SUBTRACT] &amp;&amp; (slowdown&lt;4.0f)) 
  slowdown+=0.01f; // Торможение частиц <br>
  <br>
</p>
<p class=textword>В строке ниже проверяется, нажата ли клавиша PAGE UP. Если она 
  нажата, то переменная <b>zoom</b> увеличивается. Это заставит частицы двигаться 
  ближе к нам.<br>
  <br>
</p>
<p class=textpreword>        if (keys[VK_PRIOR]) zoom+=0.1f; // Крупный план<br>
  <br>
</p>
<p class=textword>В этой строке создается противоположный эффект. Нажимая клавишу 
  Page down, <b>zoom</b> уменьшиться, и сцена сместиться глубже в экран. Это позволит 
  нам увидеть больше частиц на экране, но при этом частицы будут меньше.<br>
  <br>
</p>
<p class=textpreword>        if (keys[VK_NEXT]) zoom-=0.1f; // Мелкий план<br>
  <br>
</p>
<p class=textword>В следующей секции кода происходит проверка, была ли нажата 
  клавиша Enter. Если она нажата в первый раз, и она не удерживается уже некоторое 
  время, мы позволим компьютеру узнать, что она нажата, устанавливая <b>rp</b> 
  в <b>true</b>. Тем самым мы переключим режим радуги. Если радуга была <b>true</b>, 
  она станет <b>false</b>. Если она была <b>false</b>, то станет <b>true</b>. 
  В последней строке проверяется, была ли клавиша Enter отпущена. Если это так, 
  то <b>rp</b> устанавливается в <b>false</b>, сообщая компьютеру, что клавиша 
  больше не нажата.<br>
  <br>
</p>
<p class=textpreword>        if (keys[VK_RETURN] &amp;&amp; !rp) // нажата клавиша 
  Enter<br>
          {<br>
            rp=true; // Установка флага, что клавиша нажата <br>
            rainbow=!rainbow; // Переключение режима радуги в Вкл/Выкл <br>
          }<br>
          if (!keys[VK_RETURN]) rp=false; // Если клавиша Enter не нажата – сбросить 
  флаг <br>
  <br>
</p>
<p class=textword>Код ниже немного запутанный. В первой строке идет проверка, 
  нажата ли клавиша пробела и не удерживается ли она. Тут же проверяется, включен 
  ли режим радуги, и если так, то проверяется значение переменной <b>delay</b> 
  больше чем 25. <b>delay</b> - счетчик, который используется для создания эффекта 
  радуги. Если Вы меняете цвет каждый кадр, то все частицы будут иметь разный 
  цвет. При помощи создания задержки, группа частиц останется с одним цветом, 
  прежде чем цвет будет изменен на другой.<br>
  <br>
</p>
<p class=textword>Если клавиша пробел была нажата, или радуга включена, и задержка 
  больше чем 25, цвет будет изменен!<br>
  <br>
</p>
<p class=textpreword>        if ((keys[' '] &amp;&amp; !sp) || (rainbow &amp;&amp; 
  (delay&gt;25))) // Пробел или режим радуги <br>
          {<br>
  <br>
</p>
<p class=textword>Строка ниже была добавлена, для того чтобы режим радуги был 
  выключен, если клавиша пробел была нажата. Если бы мы не выключили режим радуги, 
  цвета продолжили бы циклически повторяться, пока клавиша Enter не была бы нажата 
  снова. Это сделано, для того чтобы можно было просмотреть все цвета, нажимая 
  пробел вместо Enter.<br>
  <br>
</p>
<p class=textpreword>          if (keys[' ']) rainbow=false; // Если пробел нажат 
  запрет режима радуги <br>
  <br>
</p>
<p class=textword>Если клавиша пробел была нажата, или режим радуги включен, и 
  задержка больше чем 25, мы позволим компьютеру узнать, что пробел было нажат, 
  делая <b>sp</b> равной <b>true</b>. Затем мы зададим задержку равной 0, чтобы 
  снова начать считать до 25. Наконец мы увеличим переменную <b>col</b>, чтобы 
  цвет изменился на следующий цвет в таблице цветов.<br>
  <br>
</p>
<p class=textpreword>          sp=true; // Установка флага нам скажет, что пробел 
  нажат <br>
            delay=0; // Сброс задержки циклической смены цветов радуги <br>
            col++;   // Изменить цвет частицы <br>
  <br>
</p>
<p class=textword>Если цвет больше чем 11, мы сбрасываем его обратно в ноль. Если 
  бы мы не сбрасывали <b>col</b> в ноль, наша программа попробовала бы найти 13-ый 
  цвет. А мы имеем только 12 цветов! Попытка получить информацию о цвете, который 
  не существует, привела бы к краху нашей программы.<br>
  <br>
</p>
<p class=textpreword>          if (col&gt;11) col=0; // Если цвет выше, то сбросить 
  его <br>
          }<br>
  <br>
</p>
<p class=textword>Наконец, если клавиша пробел больше не нажата, мы позволяем 
  компьютеру узнать это, устанавливая переменную <b>sp</b> в <b>false</b>.<br>
  <br>
</p>
<p class=textpreword>        if (!keys[' ']) sp=false; // Если клавиша пробел не 
  нажата, то сбросим флаг <br>
  <br>
</p>
<p class=textword>Теперь внесем немного управления нашими частицами. Помните, 
  что мы создали 2 переменные в начале нашей программы? Одна называлась <b>xspeed</b>, 
  и вторая называлась <b>yspeed</b>. Также Вы помните, что после того как частица 
  сгорит, мы давали ей новую скорость перемещения и добавляли новую скорость или 
  к <b>xspeed</b> или к <b>yspeed</b>. Делая это, мы можем повлиять, в каком направлении 
  частицы будут двигаться, когда они впервые созданы.<br>
  <br>
</p>
<p class=textword>Например. Пусть частица имеет скорость перемещения 5 по оси 
  X и 0 по оси Y. Если мы уменьшим <b>xspeed</b> до -10, то скорость перемещения 
  будет равна -10 (<b>xspeed</b>) +5 (начальная скорость). Поэтому вместо перемещения 
  с темпом 10 вправо, частица будет перемещаться с темпом -5 влево Понятно?<br>
  <br>
</p>
<p class=textword>Так или иначе. В строке ниже проверяем, нажата ли стрелка &quot;вверх&quot;. 
  Если это так, то <b>yspeed</b> будет увеличено. Это заставит частицы двигаться 
  вверх. Частицы будут двигаться вверх с максимальной скоростью не больше чем 
  200. Если бы они двигались быстрее этого значения, то это выглядело бы не очень 
  хорошо.<br>
  <br>
</p>
<p class=textpreword>        //Если нажата клавиша вверх и скорость по Y меньше чем 200, то увеличим скорость<br>
          if (keys[VK_UP] &amp;&amp; (yspeed&lt;200)) yspeed+=1.0f;<br>
  <br>
</p>
<p class=textword>В этой строке проверяем, нажата ли клавиша стрелка &quot;вниз&quot;. 
  Если это так, то <b>yspeed</b> будет уменьшено. Это заставит частицу двигаться 
  вниз. И снова, задан максимум скорости вниз не больше чем 200.<br>
  <br>
</p>
<p class=textpreword>        // Если стрелка вниз и скорость по Y больше чем –200, 
  то увеличим скорость падения <br>
          if (keys[VK_DOWN] &amp;&amp; (yspeed&gt;-200)) yspeed-=1.0f;<br>
  <br>
</p>
<p class=textword>Теперь мы проверим, нажата ли клавиша стрелка вправо. Если это 
  так, то <b>xspeed</b> будет увеличено. Это заставит частицы двигаться вправо. 
  Задан максимум скорости не больше чем 200.<br>
  <br>
</p>
<p class=textpreword>        // Если стрелка вправо и X скорость меньше чем 200, 
  то увеличить скорость вправо <br>
          if (keys[VK_RIGHT] &amp;&amp; (xspeed&lt;200)) xspeed+=1.0f;<br>
  <br>
</p>
<p class=textword>Наконец мы проверим, нажата ли клавиша стрелка влево. Если это 
  так... то Вы уже поняли что... <b>xspeed</b> уменьшено, и частицы двигаются 
  влево. Задан максимум скорости не больше чем 200.<br>
  <br>
</p>
<p class=textpreword>        // Если стрелка влево и X скорость больше чем –200, 
  то увеличить скорость влево <br>
          if (keys[VK_LEFT] &amp;&amp; (xspeed&gt;-200)) xspeed-=1.0f;<br>
  <br>
</p>
<p class=textword>И последнее, что мы должны сделать - увеличить переменную <b>delay</b>. 
  Я уже говорил, что <b>delay</b> управляет скоростью смены цветов, когда Вы используете 
  режим радуги.<br>
  <br>
</p>
<p class=textpreword>        delay++; // Увеличить счетчик задержки циклической смены 
  цветов в режиме радуги <br>
  <br>
</p>
<p class=textword>Так же как и во всех предыдущих уроках, проверьте, что заголовок 
  сверху окна правильный.<br>
  <br>
</p>
<p class=textpreword>        if (keys[VK_F1])             // Была нажата кнопка 
  F1?</p>
<p class=textpreword>        {</p>
<p class=textpreword>          keys[VK_F1]=FALSE;         // Если так - установим 
  значение FALSE</p>
<p class=textpreword>          KillGLWindow();            // Закроем текущее окно 
  OpenGL  </p>
<p class=textpreword>          fullscreen=!fullscreen;    // Переключим режим 
  &quot;Полный экран&quot;/&quot;Оконный&quot;</p>
<p class=textpreword>          // Заново создадим наше окно OpenGL</p>
<p class=textpreword>          if (!CreateGLWindow(&quot;NeHe's Particle Tutorial&quot;,640,480,16,fullscreen))</p>
<p class=textpreword>          {</p>
<p class=textpreword>            return 0;                // Выйти, если окно 
  не было создано</p>
<p class=textpreword>&nbsp; </p>
<p class=textpreword>          }</p>
<p class=textpreword>        }</p>
<p class=textpreword>      }</p>
<p class=textpreword>    }</p>
<p class=textpreword>  }</p>
<p class=textpreword>&nbsp; </p>
<p class=textpreword>  // Сброс</p>
<p class=textpreword>  KillGLWindow();                    // Закроем окно</p>
<p class=textpreword>  return (msg.wParam);               // Выйдем из программы</p>
<p class=textpreword>}</p>
<p class=textword>&nbsp;  </p>
<p class=textword>В этом уроке, я пробовал детально объяснять все шаги, которые 
  требуются для создания простой, но впечатляющей системы моделирования частиц. 
  Эта система моделирования частиц может использоваться в ваших собственных играх 
  для создания эффектов типа огня, воды, снега, взрывов, падающих звезд, и так 
  далее. Код может быть легко модифицирован для обработки большего количество 
  параметров, и создания новых эффектов (например, фейерверк).<br>
  <br>
</p>
<p class=textword>Благодарю Richard Nutman за предложение о том, что частицы можно 
  позиционировать с помощью <b>glVertex3f()</b> вместо сброса матрицы модели просмотра 
  и перепозиционирования каждой частицы с помощью <b>glTranslatef()</b>. Оба метода 
  эффективны, но его метод уменьшил количество вычислений для вывода каждой частицы, 
  что вызвало увеличение быстродействия программы.<br>
  <br>
</p>
<p class=textword>Благодарю Antoine Valentim за предложение использовать полоски 
  из треугольников для ускорения программы и введения новой команды в этом уроке. 
  Замечания к этому уроку были великолепными, и я признателен за это!<br>
  <br>
</p>
<p class=textword>Я надеюсь, что Вам понравился этот урок. Если Вы что-то не понимаете, 
  или Вы нашли ошибку в этом уроке, пожалуйста, сообщите мне об этом. Я хочу сделать 
  уроки лучше. Ваши замечания очень важны!<br>
  <br>
</p>

<p class="textnoalign" align="right">
<font color="#0000A0"><b> © Jeff Molofee (NeHe)</b></font><br>
</p>          
</div>
<div id="end">
          <p><a href="http://pmg-ru.narod.ru/"
			onmouseover=" return event_over(this,'Программирование магических игр')  "
			onmouseout=" return event_out(this) "><font class="link"><b>PMG</b></font></a> 
            <font class="comment">&nbsp;9 августа 2002&nbsp;(c)&nbsp;</font> 
        <a href="mailto:pmg-ru@narod.ru"
	onmouseover=" return event_over(this,'Почта переводчику')  " 
	onmouseout=" return event_out(this) "> <font class="link"><b>Сергей Анисимов</b></font></a> 
          </p>
</div>
<div id="counter">

    <script language="javascript">
d=document;rn=Math.random();
y="<a href='http://u013.94.spylog.com/cnt?f=3&rn="+rn+"' target=_blank><img src='http://u013.94.spylog.com/cnt?";
y+="p=1&f=4&rn="+rn+"' border=0 width=88 height=31 ></a>"; d.write(y);
</script>
    <noscript>
<a href="http://u013.94.spylog.com/cnt?f=3&p=1" target=_blank>
<img src="http://u013.94.spylog.com/cnt?p=1&f=4" alt='SpyLog' border='0' width=88 height=31 ></a>
</noscript>
</div>
</center>

<script language="JavaScript">
<!--
form_print();
//-->
</script>

</body>
</html>
