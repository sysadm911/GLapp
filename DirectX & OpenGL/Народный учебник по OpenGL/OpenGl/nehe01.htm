
<!doctype html public "-//w3c//dtd html 3.2 final//ru">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=windows-1251">
<meta name="description"
content="Переводы по OpenGL, трехмерная графика, игры, мультимедия
Translations Russian OpenGL
">
<meta name="keyword"
content="Программирование,игры,3D,трехмерная графика,OpenGL,NeHe">
<meta name="keyword"
content="programming,C,C++,game,graphics">
<title>Урок 1. Инициализация в Windows</title>
<link rel="stylesheet" href="pmg.css" type="text/css">
</head>

<html>

<body bgcolor="#B4B7DC" link="#D621AD" link="#800080" vlink="#800080">

<!-- SpyLOG v2 f:0210 --> 
<script language="javascript"> 
u="u013.94.spylog.com";d=document;nv=navigator;na=nv.appName;p=1; 
bv=Math.round(parseFloat(nv.appVersion)*100); 
n=(na.substring(0,2)=="Mi")?0:1;rn=Math.random();z="p="+p+"&rn="+rn+"&tl=0&ls=0&ln=0";y=""; 
y+="<img src='http://"+u+"/cnt?"+z+ 
"&r="+escape(d.referrer)+"&pg="+escape(window.location.href)+"' border=0 width=1 height=1 alt='SpyLOG'>"; 
d.write(y);if(!n) { d.write("<"+"!--"); }//--></script><noscript> 
<img src="http://u013.94.spylog.com/cnt?p=1" alt='SpyLOG' border='0' width=1 height=1 > 
</noscript><script language="javascript1.2"><!-- 
if(!n) { d.write("--"+">"); }//--></script> 
<!-- SpyLOG -->

<script src='nehe.js' language="javascript">
<!--
//-->
</script>

<center>
<div id="top">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
    <tr>
        <td width="20%" align="center" valign="center">
        <img src="nehelogo.jpg" align="left" hspace="0" width="125" height="50" alt="NeHe Tutorials">
        </td>
        <td width="60%" align="center">
	<a href="index.html"
	onmouseover=" return event_over(this,'NeHe Ru.')  "
        onmouseout=" return event_out(this) ">
        <font class="linksbig">
        Народный учебник по OpenGL</font></a><br>
        </td>
        <td width="20%" align="center" valign="center">
        <img src="nehe01.jpg" align="right" hspace="0" width="80" height="60" alt="Урок 1. OpenGL">
        </td>
    </tr>
</table>
</div>

<div id="head">
<p class="head1">
Урок 1. Инициализация в Windows
</p>
</div>

<div id="main" bgcolor="#ADADFF">
<p class="textnoalign" align="left">

<a href="http://nehe.gamedev.net/tutorials/lesson.asp?l=1" target="_blank"
onmouseover=" return event_over(this,this)  "
onmouseout=" return event_out(this) ">
<font class="link"><b>Setting Up An OpenGL Window</b></font></a>
<br>
<br>
</p>

<p class="text">
Я начинаю это пособие непосредственного с кода, разбитого на секции, каждая из которых будет подробно 
комментироваться. Первое, что вы должны сделать  - это создать проект в Visual C++. Если это для вас 
затруднительно, то  вам стоит для начала изучить C++, а уже затем переходить к OpenGL. 
</p> 
 
<p class="text">
После того как вы создадите новое приложение в Visual C++, Вам надо будет добавить для сборки проекта 
библиотеки OpenGL. В меню Project/setting, выберите закладку LINK. В строке "Object/Library Modules"  
добавьте "OpenGL32.lib GLu32.lib GLaux.lib". Затем кликните по OK. Теперь все готово для создания программы 
с OpenGL.
</p> 
 
<p class="text">
Первые четыре строки, которые вы введете, сообщают компилятору какие библиотечные файлы использовать. 
Они должны выглядят так:
</p>

<p  ><font class="textpreword">#include &lt;windows.h&gt;                      // Заголовочный файл для Windows<br>
#include &lt;gl\gl.h&gt;                        // Заголовочный файл для OpenGL32 библиотеки<br>
#include &lt;gl\glu.h&gt;                       // Заголовочный файл для GLu32 библиотеки<br>
#include &lt;gl\glaux.h&gt;                     // Заголовочный файл для GLaux библиотеки</font></p  >

<p class="text">
Далее, необходимо инициализировать все переменные, которые будут использованы в вашей программе. Эта 
программа будет создавать пустое OpenGL окно, поэтому мы не будем нуждаться в большом количестве 
переменных. То немногое, что мы устанавливаем - очень важно, и будет использоваться в каждой программе с 
OpenGL, которую вы напишите с использованием этого кода. 
</p>
 
<p class="text">
Первые две строки устанавливают Контексты Рендеринга, которые связывает вызовы OpenGL с окном Windows. 
Контекст Рендеринга OpenGL определен как hRC. Для того чтобы рисовать в окне, вам необходимо создать 
Контекст Устройства Windows, который определен как hDC. DC соединяет окно с GDI. RC соединяет OpenGL с 
DC.
</p>

<p  ><font class="textpreword">static HGLRC hRC;               // Постоянный контекст рендеринга<br>
static HDC hDC;                 // Приватный контекст устройства GDI</font></p  >

<p class="text">
Последняя переменная, в которой мы будем нуждаться, это массив, который мы используем для отслеживания 
нажатия клавиш на клавиатуре. Есть много путей следить за нажатиями на клавиатуре, но я использую этот путь. 
При этом можно отслеживать нажатие более чем одной клавиши одновременно. 
</p>
<p  ><font class="textpreword">BOOL    keys[256];              // Массив для процедуры обработки клавиатуры</font></p  >

<p class="text">
В следующей секции кода будут произведены все настройки для OpenGL. Мы установим цвет для очистки 
экрана, включим глубину буфера, разрешим плавное сглаживание цветов, и что наиболее важно, мы установим 
рендеринг на экран в перспективе, используя ширину и высоту окна. Эта процедура не должна быть вызвана до 
тех пор, пока OpenGL окно будет сделано.
</p>

<p  ><font class="textpreword">GLvoid InitGL(GLsizei Width, GLsizei Height)    // Вызвать после создания окна GL<br>
{</font></p  >


<p class="text">
В следующей строке устанавливается цвет, которым будет очищен экран. Для тех, кто не знает, как устроены 
цвета, я постараюсь кратко объяснять. Все значения могут быть в диапазоне от 0.0f до 1.0f, при этом 0.0 самый 
темный, а 1.0 самый светлый. Первое число в glClearColor - это интенсивность красного, второе – зеленного, 
третье – синего. Наибольшее значение – 1.0f, является самым ярким значением данного цвета. Последние число - 
для альфа значения. Когда начинается очистка экрана, я не когда не волнуюсь о четвертом числе. Пока оно будет 
0.0f. Как его использовать, я объясню в другом уроке.
</p>
 

<p class="text">
Поэтому, если вы вызвали glClearColor(0.0f,0.0f,1.0f,0.0f) вы произведете очистку экрана, с последующим 
закрашиванием его в ярко синий цвет. Если вы вызвали glClearColor(0.5f,0.0f,0.0f,0.0f) экран будет заполнен 
умеренно красным цветом. Не очень ярким (1.0f) и не темным (0.0f), а именно умеренно красным. Для того 
чтобы сделать белый фон, вы должны установить все цвета в (1.0f). Черный - как можно ниже (0.0f).
</p>

<p  ><font class="textpreword">glClearColor(0.0f, 0.0f, 0.0f, 0.0f);   // Очистка экрана в черный цвет</font></p  >

<p class="text">
Следующие три строки создают Буфер Глубины. Думайте о буфере глубины как о слоях на экране. Буфер глубины 
указывает, как далеко объекты находятся от экрана. Мы не будем реально использовать буфер глубины в этой 
программе, но любая программа с OpenGL, которая рисует на экране в 3D будет его использовать. Он позволяет 
сортировать объекты для отрисовки, поэтому квадрат расположенный под кругом не изображен будет поверх 
круга. Буфер глубины очень важная часть OpenGL.
</p>

<p  ><font class="textpreword">        glClearDepth(1.0);                      // Разрешить очистку буфера глубины<br>
        glDepthFunc(GL_LESS);                   // Тип теста глубины<br>
        glEnable(GL_DEPTH_TEST);                // разрешить тест глубины</font></p  >


<p class="text">
Следующие пять строк разрешают плавное сглаживание (антиалиасинг - antialiasing)(которое я буду объяснять 
позднее) и установку экрана для перспективного просмотра. Отдаленные предметы на экране кажутся меньшими, 
чем ближние. Это придает сцене реалистичный вид. Перспектива вычисляется под углом просмотра 45 
градусов на основе ширины и высоты окна. 0.1f, 100.0f глубина экрана. 
</p>
 
<p class="text">
glMatrixMode(GL_PROJECTION) сообщает о том, что следующие команды будут воздействовать на матрицу 
проекции. glLoadIdentity() – это функция работает подобно сбросу. Раз сцена сброшена, перспектива вычисляется 
для сцены. glMatrixMode(GL_MODELVIEW) сообщает, что любые новые трансформации будут воздействовать 
на матрицу просмотра модели. Не волнуйтесь, если вы что-то не понимаете этот материал, я буду обучать всему 
этому в дальнейших уроках. Только запомините, что НАДО сделать, если вы хотите красивую перспективную 
сцену.
</p>

<p  ><font class="textpreword">        glShadeModel(GL_SMOOTH);        // разрешить плавное цветовое сглаживание<br>
        glMatrixMode(GL_PROJECTION);    // Выбор матрицы проекции<br>
        glLoadIdentity();               // Сброс матрицы проекции<br>
        gluPerspective(45.0f,(GLfloat)Width/(GLfloat)Height,0.1f,100.0f);<br>
                                // Вычислить соотношение геометрических размеров для окна<br>
        glMatrixMode(GL_MODELVIEW);     // Выбор матрицы просмотра модели<br>
}</font></p  >

<p class="text">
Следующая секция кода очень простая, по сравнению с предыдущим кодом. Это функция масштабирования 
сцены, вызываемая OpenGL всякий раз, когда вы изменяете размер окна (допустим, что вы используете окна 
чаще, чем полноэкранный режим, который мы не рассматриваем). Даже если вы не делаете изменение размеров 
окна (например, если вы находитесь в полноэкранном режиме), эта процедура все равно должна быть вызвана 
хоть один раз, обычно во время запуска программы. Замечу, что сцена масштабируется, основываясь на ширине 
и высоте окна, которое отображается.
</p>
<p  ><font class="textpreword">GLvoid ReSizeGLScene(GLsizei Width, GLsizei Height)<br>
{<br>
        if (Height==0)          // Предотвращение деления на ноль, если окно слишком мало<br>
                Height=1;<br>
<br>
        glViewport(0, 0, Width, Height);<br>
                // Сброс текущей области вывода и перспективных преобразований<br>
<br>
        glMatrixMode(GL_PROJECTION);            // Выбор матрицы проекций<br>
        glLoadIdentity();                       // Сброс матрицы проекции<br>
<br>
        gluPerspective(45.0f,(GLfloat)Width/(GLfloat)Height,0.1f,100.0f);<br>
                // Вычисление соотношения геометрических размеров для окна<br>
        glMatrixMode(GL_MODELVIEW);     // Выбор матрицы просмотра модели<br>
}</font></p  >

<p class="text">
В этой секции содержится весь код для рисования. Все, что вы планируете для отрисовки на экране, будет 
содержатся в этой секции кода. В каждом уроке, после этого будет добавлять код в эту секцию программы. Если 
вы уже понимаете OpenGL, вы можете попробовать добавить в код простейшие формы на OpenGL, ниже вызова 
glLoadIdentity(). Если вы новичок в OpenGL, подождите до следующего моего урока. Сейчас все что мы сделаем, 
это очистка экрана цветом, который мы определили выше, очистка буфера глубины и сброс сцены.
</p>

<p  ><font class="textpreword">GLvoid DrawGLScene(GLvoid)<br>
{<br>
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);<br>
                // очистка Экрана и буфера глубины<br>
        glLoadIdentity();<br>
                // Сброс просмотра<br>
}</font></p  >

<p class="text">
Следующая секция кода наиболее важная секция в этой программе. Это установка окна Windows, установка 
формата пикселя, обработка при изменении размеров, при нажатии на клавиатуру, и закрытие программы.
</p>
 
<p class="text">
Первые четыре строки делают следующее: переменная hWnd – является указателем на окно.  Переменная 
message – сообщения, передаваемые вашей программе системой. Переменные wParam и lParam содержат 
информацию, которая посылается вместе с сообщением, например такая как ширина и высота окна.
</p>

<p  ><font class="textpreword">LRESULT CALLBACK WndProc(       HWND    hWnd,<br>
                                UINT    message,<br>
                                WPARAM  wParam,<br>
                                LPARAM  lParam)</font></p  >

<p class="text">
Код между скобками устанавливает формат пикселей. Я предпочитаю не использовать режим индексации цвета. 
Если вы не знаете, что это означает, не заботьтесь об этом. Формат описания пикселя описывает, как OpenGL 
будет выводить в окно.  Большинство кода игнорируется, но зачастую это необходимо. Я буду помещать 
короткий комментарий для каждой строки. Знак вопроса означает, что я не уверен, что это строка кода делает (я 
только человек!).
</p>

<p  ><font class="textpreword">{<br>
        RECT    Screen;         // используется позднее для размеров окна<br>
        GLuint  PixelFormat;<br>
        static  PIXELFORMATDESCRIPTOR pfd=<br>
        {<br>
                sizeof(PIXELFORMATDESCRIPTOR),  // Размер этой структуры<br>
        1,                              // Номер версии (?)<br>
        PFD_DRAW_TO_WINDOW |            // Формат для Окна<br>
        PFD_SUPPORT_OPENGL |            // Формат для OpenGL<br>
        PFD_DOUBLEBUFFER,               // Формат для двойного буфера<br>
        PFD_TYPE_RGBA,                  // Требуется RGBA формат<br>
        16,                             // Выбор 16 бит глубины цвета<br>
        0, 0, 0, 0, 0, 0,                       // Игнорирование цветовых битов (?)<br>
        0,                              // нет буфера прозрачности<br>
        0,                              // Сдвиговый бит игнорируется (?)<br>
        0,                              // Нет буфера аккумуляции<br>
        0, 0, 0, 0,                             // Биты аккумуляции игнорируются (?)<br>
        16,                             // 16 битный Z-буфер (буфер глубины)  <br>
        0,                              // Нет буфера траффарета<br>
        0,                              // Нет вспомогательных буферов (?)<br>
        PFD_MAIN_PLANE,                 // Главный слой рисования<br>
        0,                              // Резерв (?)<br>
        0, 0, 0                         // Маски слоя игнорируются (?)<br>
        };</font></p  >

<p class="text">
Эта секция кода обрабатывает системные сообщения. Они генерируются, когда вы выходите из программы, 
нажимаете на клавиши, передвигаете окно, и так далее, каждая секция "case"  обрабатывает свой тип сообщения. 
Если вы что вставите в эту секцию, не ожидайте, что ваш код будет работать должным образом, или вообще 
работать.
</p>

<p  ><font class="textpreword">        switch (message)        // Тип сообщения<br>
        {</font></p  >

<p class="text">
WM_CREATE сообщает программе, что оно должно быть создано. Вначале мы запросим DC (контекст 
устройства) для вашего окна. Помните, без него мы не можем рисовать в окно. Затем мы запрашиваем формат 
пикселя. Компьютер будет выбирать формат, который совпадает или наиболее близок к формату, который мы 
запрашиваем. Я не делаю здесь множества проверок на ошибки, чтобы сократить код, но это неправильно. Если 
что-то не работает, я просто добавляю необходимый код. Возможно, вы захотите посмотреть, как работают 
другие форматы пикселей.
</p>

<p  ><font class="textpreword">        case WM_CREATE:<br>
                hDC = GetDC(hWnd);      // Получить контекст устройства для окна<br>
                PixelFormat = ChoosePixelFormat(hDC, &pfd);<br>
                        // Найти ближайшее совпадение для нашего формата пикселов</font></p  >

<p class="text">
Если подходящий формат пикселя не может быть найден, будет выведено сообщение об ошибке с 
соответствующем уведомлением. Оно будет ждать, когда вы нажмете на OK, до выхода из программы.
</p>

<p  ><font class="textpreword">        if (!PixelFormat)<br>
                {<br>
                        MessageBox(0,"Can't Find A Suitable <br>
                        PixelFormat.","Error",MB_OK|MB_ICONERROR);<br>
                        PostQuitMessage(0);<br>
                        // Это сообщение говорит, что программа должна завершится<br>
                break;  // Предтовращение повтора кода<br>
                }</font></p  >


<p class="text">
Если подходящий формат найден, компьютер будет пытаться установить формат пикселя для контекста 
устройства. Если формат пикселя не может быть установлен по какой-то причине, выскочит сообщение об 
ошибке, что формат пикселя не найден, и будет ожидать, пока Вы не нажмете кнопку OK, до выхода из 
программы.
</p>

<p  ><font class="textpreword">        if(!SetPixelFormat(hDC,PixelFormat,&pfd))<br>
                {<br>
                        MessageBox(0,"Can't Set The <br>
                        PixelFormat.","Error",MB_OK|MB_ICONERROR);<br>
                        PostQuitMessage(0);<br>
                        break;<br>
                }</font></p  >

<p class="text">
Если код сделан, как показано выше, будет создан DC (контекст устройства), и установлен подходящий формат 
пикселя. Сейчас мы создадим Контекст Рендеринга, для этого OpenGL использует DC. wglCreateContext будет 
захватывать Контекст Рендеринга и сохранять его в переменной hRC. Если по какой-то причине Контекст 
Рендеринга не доступен, выскочит сообщение об ошибке. Нажмите OK для вызова программы.
</p>
<p  ><font class="textpreword">        hRC = wglCreateContext(hDC);<br>
        if(!hRC)<br>
                {<br>
                MessageBox(0,"Can't Create A GL Rendering <br>
                Context.","Error",MB_OK|MB_ICONERROR);<br>
                PostQuitMessage(0);<br>
                break;<br>
                }</font></p  >

<p class="text">
Сейчас мы имеем Контекст Рендеринга, и нам необходимо сделать его активным, для того чтобы OpenGL мог 
рисовать в окно. Снова, если по не которой причине это не может быть сделано, выскочит сообщение об ошибке. 
Кликните OK в окошке ошибки для выхода из программы.
</p>
<p  ><font class="textpreword">        if(!wglMakeCurrent(hDC, hRC))<br>
                {<br>
                MessageBox(0,"Can't activate GLRC.","Error",MB_OK|MB_ICONERROR);<br>
                PostQuitMessage(0);<br>
                break;<br>
                }</font></p  >

<p class="text">
Если все прошло удачно, то у нас есть все для того, чтобы создать область рисования OpenGL. GetClientRect 
возвратит нам ширину и высоту окна. Мы запомним ширину справа, и высоту снизу. После того как мы 
получили ширину и высоту, инициализируем экран OpenGL. Мы делаем это при помощи вызова InitGL, 
передавая в параметрах право и низ (ширину и высоту).
</p>

<p  ><font class="textpreword">                GetClientRect(hWnd, &Screen);<br>
                InitGL(Screen.right, Screen.bottom);<br>
                break;</font></p  >

<p class="text">
WM_DESTROY и WM_CLOSE очень похожи. Программа будет посылать это сообщение каждый раз, когда вы 
выходите из программы, нажав ALT-F4, или если вы послали PostQuitMessage(0) также как мы делали, когда 
происходила ошибка. 
</p>
 
<p class="text">
ChangeDisplaySettings(NULL,0) будет переключать разрешение рабочего стола обратно, делая его таким, каким 
мы переключались из него в полноэкранный режим. ReleaseDC(hWnd,hDC) уничтожает контекст устройства 
окна. По существу это уничтожает окно OpenGL.
</p>

<p  ><font class="textpreword">                case WM_DESTROY:<br>
                case WM_CLOSE:<br>
                ChangeDisplaySettings(NULL, 0);<br>
<br>
                wglMakeCurrent(hDC,NULL);<br>
                wglDeleteContext(hRC);<br>
                ReleaseDC(hWnd,hDC);<br>
<br>
                PostQuitMessage(0);<br>
                break;</font></p  >

<p class="text">
WM_KEYDOWN вызывается всякий раз при нажатии клавиши. Клавиша, которая была нажата, сохраняется в 
переменной wParam. Итак, что же делает следующий код... Скажем, я нажал 'A'. Буква фактически – это число, 
которое ее представляет. Поэтому в ячейку, которая представляет 'A' заносится TRUE. Позднее, в коде, если я 
проверю состояние ячейки и увижу TRUE, то я знаю, что клавиша 'A' действительно в этот момент нажата.
</p>

<p  ><font class="textpreword">                case WM_KEYDOWN:<br>
                keys[wParam] = TRUE;<br>
                break;</font></p  >

<p class="text">
WM_KEYUP вызывается всякий раз, когда клавиша отпускается. Клавиша, которая отжата, также сохраняется в 
переменной wParam. Поэтому, когда я отпускаю клавишу 'A', это делает ячейку для клавиши 'A' равной FALSE. 
Когда я проверю ячейку, для того чтобы увидеть нажата ли клавиша 'A', она вернет FALSE, что означает "нет, 
она не нажата".
</p>

<p  ><font class="textpreword">                case WM_KEYUP:<br>
                keys[wParam] = FALSE;<br>
                break;</font></p  >

<p class="text">
И последнее, что я сделаю - обработаю изменение размеров окна. Возможно, кажется, что бесмыслено добавлять 
этот код, когда программа запущена в полноэкранном режиме, но без этого кода, экран OpenGL не появится. 
Поверьте, мне это очень важно. 
</p>
 
<p class="text">
Всякий раз сообщение WM_SIZE посылается Windows с двумя параметрами - новая ширина, и новая высота 
экрана. Эти параметры сохранены в LOWORD(lParam) и HIWORD(lParam). Поэтому вызов ReSizeGLScene 
изменяет размеры экрана. Это передает высоту и ширину в эту секцию кода.
</p>

<p  ><font class="textpreword">                case WM_SIZE:<br>
                ReSizeGLScene(LOWORD(lParam),HIWORD(lParam));<br>
                break;</font></p  >

<p class="text">
Затем, дадим Windows обработать все сообщения, которые мы не обрабатываем и завершим процедуру.
</p>

<p  ><font class="textpreword">        default:<br>
        return (DefWindowProc(hWnd, message, wParam, lParam));<br>
        }<br>
        return (0);<br>
}</font></p  >

<p class="text">
Это то место, где начинается программа,  где создается окно, где делается практически все, кроме рисования. Мы 
начинаем с создания окна.
</p>

<p  ><font class="textpreword">int WINAPI WinMain(HINSTANCE hInstance,HINSTANCE hPrevInstance, <br>
                LPSTR lpCmdLine,int nCmdShow)<br>
{<br>
        MSG             msg;    // Структура сообщения Windows<br>
        WNDCLASS        wc; // Структура класса Windows для установки типа окна<br>
        HWND            hWnd;   // Сохранение дискриптора окна</font></p  >

<p class="text">
Флаги стиля CS_HREDRAW и CS_VREDRAW принуждают перерисовать окно  всякий раз, когда оно 
перемещается. CS_OWNDC создает скрытый DC для окна. Это означает, что DC не используется совместно 
нескольким приложениями. WndProc - процедура, которая перехватывает сообщения для программы. hIcon 
установлен равным нулю, это означает, что мы не хотим ICON в окне, и для мыши используем стандартный 
указатель. Фоновый цвет не имеет значения (мы установим его в GL). Мы не хотим меню в этом окне, поэтому 
мы используем установку его в NULL, и имя класса – это любое имя которое вы хотите. 
</p>

<p  ><font class="textpreword">        wc.style                = CS_HREDRAW | CS_VREDRAW | CS_OWNDC;<br>
        wc.lpfnWndProc          = (WNDPROC) WndProc;<br>
        wc.cbClsExtra           = 0;<br>
        wc.cbWndExtra           = 0;<br>
        wc.hInstance            = hInstance;<br>
        wc.hIcon                = NULL;<br>
        wc.hCursor              = LoadCursor(NULL, IDC_ARROW);<br>
        wc.hbrBackground        = NULL;<br>
        wc.lpszMenuName         = NULL;<br>
        wc.lpszClassName        = "OpenGL WinClass";</font></p  >

<p class="text">
Сейчас мы регистрируем класс. Если произошла ошибка, появится соответствующее сообщение. Кликните на OK 
в коробочку об ошибке и будете выкинуты из программы.
</p>

<p  ><font class="textpreword">        if(!RegisterClass(&wc))<br>
        {<br>
        MessageBox(0,"Failed To Register The Window <br>
        Class.","Error",MB_OK|MB_ICONERROR);<br>
        return FALSE;<br>
        }</font></p  >

<p class="text">
Сейчас мы сделаем окно. Не смотря на то, что мы делаем окно здесь, это не вызовет OpenGL до тех пор, пока 
сообщение WM_CREATE не послано. Флаги WS_CLIPCHILDREN и WS_CLIPSIBLINGS требуются для OpenGL. 
Очень важно, чтобы вы добавили их здесь. Я люблю использовать всплывающее окно, оно хорошо работает в 
полноэкранном режиме.
</p>

<p  ><font class="textpreword">        hWnd = CreateWindow(<br>
        "OpenGL WinClass",<br>
        "Jeff Molofee's GL Code Tutorial ... NeHe '99", // Заголовок вверху окна<br>
<br>
        WS_POPUP |<br>
        WS_CLIPCHILDREN |<br>
        WS_CLIPSIBLINGS,<br>
<br>
        0, 0,                   // Позиция окна на экране<br>
        640, 480,               // Ширина и высота окна<br>
<br>
        NULL,<br>
        NULL,<br>
        hInstance,<br>
        NULL);</font></p  >

<p class="text">
Далее -  обычная проверка на ошибки. Если окно не было создано по какой-то причине, сообщение об ошибке 
выскочит на экран. Давите OK и завершайте программу.
</p>

<p  ><font class="textpreword">        if(!hWnd)<br>
        {<br>
        MessageBox(0,"Window Creation Error.","Error",MB_OK|MB_ICONERROR); <br>
                return FALSE;<br>
        }</font></p  >

<p class="text">
Следующая секция кода вызывает у многих людей массу проблем … переход в полноэкранный режим. Здесь 
важна одна вещь, которую вы должны запомнить, когда переключаетесь в полноэкранный режим - сделать 
ширину и высоту в полноэкранном режиме необходимо туже самую, что и ширина и высота, которую вы сделали 
в своем окне. 
</p> 

<p class="text">
Я не устанавливаю глубину цвета, когда я переключаю полноэкранный режим. Всякий раз, когда я пробовал 
переключать глубину цвета, я получал сверхъестественные запросы от Windows чтобы сделать перезагрузку 
компьютера для переключения нового режима цвета. Я не уверен, надо ли удовлетворять это сообщение, но я 
решил оставлять компьютер с той глубиной цвета, которая была до запуска GL программы. 
</p> 

<p class="text">
Важно отметить, что этот код не будет скомпилирован на Cи. Это файл должен быть сохранен как .CPP файл.
</p>

<p  ><font class="textpreword">DEVMODE dmScreenSettings;                       // Режим работы<br>
<br>
memset(&dmScreenSettings, 0, sizeof(DEVMODE));          // Очистка для хранения установок<br>
dmScreenSettings.dmSize = sizeof(DEVMODE);              // Размер структуры Devmode<br>
dmScreenSettings.dmPelsWidth    = 640;                  // Ширина экрана<br>
dmScreenSettings.dmPelsHeight   = 480;                  // Высота экрана<br>
dmScreenSettings.dmFields       = DM_PELSWIDTH | DM_PELSHEIGHT; // Режим Пиксела<br>
ChangeDisplaySettings(&dmScreenSettings, CDS_FULLSCREEN);<br>
        // Переключение в полный экран</font></p  >
							 

<p class="text">
ShowWindow название этой функции говорит само за себя - она показывает окно, которое вы создали на экране. 
Я люблю это делать, после того как я переключусь в полноэкранный режим, хотя я не уверен, что это имеет 
значения. UpdateWindow обновляет окно, SetFocus делает окно активным, и вызывает wglMakeCurrent(hDC,hRC) 
чтобы убедиться, что Контекст рендеринга не освобожден.
</p>

<p  ><font class="textpreword">        ShowWindow(hWnd, SW_SHOW);<br>
        UpdateWindow(hWnd);<br>
        SetFocus(hWnd);</font></p  >

<p class="text">
Теперь мы создадим бесконечный цикл. Есть только один момент выхода из цикла, - когда нажали ESC. При 
этом программе будет отправлено сообщение о выходе, и она прервется.
</p>

<p  ><font class="textpreword">        while (1)<br>
        {<br>
                // Обработка всех сообщений<br>
                while (PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE))<br>
                {<br>
                        if (GetMessage(&msg, NULL, 0, 0))<br>
                        {<br>
                                TranslateMessage(&msg);<br>
                                DispatchMessage(&msg);<br>
                        }<br>
                        else<br>
                        {<br>
                                return TRUE;<br>
                        }<br>
                }</font></p  >

<p class="text">
DrawGLScene вызывает ту часть программы, которая фактически рисует объекты OpenGL. В этой программе мы 
оставим эту часть секции пустой, все что будет сделано - очистка экрана черным цветом. В следующих уроках я 
покажу, как применять OpenGL для рисования.  
</p>
 
<p class="text">
SwapBuffers(hDC) очень важная команда. Мы имеем окно с установленной двойной буферизацией. Это означает, 
что изображение рисуется на скрытом окне (называемым буфером). Затем, мы говорим компьютеру переключить 
буфера, скрытый буфер копируется на экран. При этом получается плавная анимация без рывков, и зритель не 
замечает отрисовку объектов.
</p>

<p  ><font class="textpreword">        DrawGLScene();                          // Нарисовать сцену<br>
        SwapBuffers(hDC);                               // Переключить буфер экрана<br>
        if (keys[VK_ESCAPE]) SendMessage(hWnd,WM_CLOSE,0,0);    // Если ESC - выйти<br>
        }<br>
}</font></p  >

<p class="text">
В этом уроке я попытался объяснить как можно больше деталей каждого шага запутанной установки, и создания 
ваших собственных полноэкранных OpenGL программ, которые будут завершаться при нажатии ESC. Я потратил 
3 дня и 13 часов для написания этого урока. Если вы имеете любые комментарии или вопросы, пожалуйста, 
пошлите их мне по электронной почте. Если вы ощущаете, что я некорректно комментировал что-то или что код 
должен быть лучше в некоторых секциях по некоторым причинам, пожалуйста, дайте мне знать. Я хочу сделать 
уроки по OpenGL хорошими насколько смогу. Я заинтересован в обратной связи.
</p>

<p class="textnoalign" align="right">
<font color="#0000A0"><b> © Jeff Molofee (NeHe) </b></font><br>
</p>          
</div>

<div id="end">
<p align="center">
<a href="http://pmg-ru.narod.ru/"
onmouseover=" return event_over(this,'Программирование магических игр')  "
onmouseout=" return event_out(this) ">
<font class="link"><b>PMG</b></font></a>

<font class="comment">&nbsp;6 марта 2001&nbsp;(c)&nbsp;</font>

<a href="mailto:pmg-ru@narod.ru"
onmouseover=" return event_over(this,'Почта переводчику')  "
onmouseout=" return event_out(this) ">
<font class="link"><b>Сергей Анисимов</b></font></a>
</p>
</div>

<div id="counter">
<script language="javascript"> 
d=document;rn=Math.random(); 
y="<a href='http://u013.94.spylog.com/cnt?f=3&rn="+rn+"' target=_blank><img src='http://u013.94.spylog.com/cnt?"; 
y+="p=1&f=4&rn="+rn+"' border=0 width=88 height=31 ></a>"; d.write(y); 
</script><noscript> 
<a href="http://u013.94.spylog.com/cnt?f=3&p=1" target=_blank> 
<img src="http://u013.94.spylog.com/cnt?p=1&f=4" alt='SpyLog' border='0' width=88 height=31 ></a> 
</noscript>
</div>
</center>

<script language="JavaScript">
<!--
form_print();
//-->
</script>

</body>
</html>
