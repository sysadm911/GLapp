
<!doctype html public "-//w3c//dtd html 3.2 final//ru">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=windows-1251">
<meta name="description"
content="Переводы по OpenGL, трехмерная графика, игры, мультимедия
Translations Russian OpenGL
">
<meta name="keyword"
content="Программирование,игры,3D,трехмерная графика,OpenGL,NeHe">
<meta name="keyword"
content="programming,C,C++,game,graphics">
<title>Урок 12. Использование списков отображения</title>
<link rel="stylesheet" href="pmg.css" type="text/css">
</head>


<body bgcolor="#B4B7DC" link="#800080" vlink="#800080">
<!-- SpyLOG v2 f:0210 -->
<script language="javascript">
u="u013.94.spylog.com";d=document;nv=navigator;na=nv.appName;p=1;
bv=Math.round(parseFloat(nv.appVersion)*100);
n=(na.substring(0,2)=="Mi")?0:1;rn=Math.random();z="p="+p+"&rn="+rn+"&tl=0&ls=0&ln=0";y="";
y+="<img src='http://"+u+"/cnt?"+z+
"&r="+escape(d.referrer)+"&pg="+escape(window.location.href)+"' border=0 width=1 height=1 alt='SpyLOG'>";
d.write(y);if(!n) { d.write("<"+"!--"); }//--></script><noscript>
<img src="http://u013.94.spylog.com/cnt?p=1" alt='SpyLOG' border='0' width=1 height=1>
</noscript><script language="javascript1.2"><!--
if(!n) { d.write("--"+">"); }//--></script>
<!-- SpyLOG -->
<script src='nehe.js' language="javascript">
<!--
//-->
</script>

<center>
<div id="top">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
    <tr>
        <td width="20%" align="center" valign="center">
        <img src="nehelogo.jpg" align="left" hspace="0" width="125" height="50" alt="NeHe Tutorials">
        </td>
        <td width="60%" align="center">
	<a href="index.html"
	onmouseover=" return event_over(this,'NeHe Ru.')  "
        onmouseout=" return event_out(this) ">
        <font class="linksbig">
        Народный учебник по OpenGL</font></a><br>
        </td>
        <td width="20%" align="center" valign="center">
        <img src="nehe12.jpg" align="right" hspace="0" width="80" height="60" alt="Урок 12. OpenGL">
        </td>
    </tr>
</table>
</div>

<div id="head">
<p class="head1">
Урок 12. Использование списков отображения
        </p>
</div>

<div id="main" bgcolor="#ADADFF">
<p class="textnoalign" align="left">

<a href="http://nehe.gamedev.net/tutorials/lesson.asp?l=12" target="_blank"
onmouseover=" return event_over(this,this)  "
onmouseout=" return event_out(this) ">
<font class="link"><b>Display Lists</b></font></a>
<br>
<br>
</p>

<p class="text">
В этом уроке я научу вас, как использовать Списки Отображения (Display Lists). 
Использование списков отображения не только ускоряет ваш код, списки также 
позволяют уменьшить количество строк, которые необходимо написать для создания 
простой GL сцены.
</p>
<p class="text">
Например. Скажем, вы создаете в игре астероиды. Каждый уровень начинается как 
минимум с двух астероидов. Итак, вы сидите с вашей графической бумагой ( :)) ) и 
рисуете, как можно создать 3D астероиды. После того, как вы все нарисовали, вы 
создаете астероид в OpenGL, используя полигоны или четырехугольники. Скажем 
астероид - это октагон (восемь сторон). Если вы умны, вы создаете цикл, и 
рисуете астероид один раз в цикле. Вы сделаете это, написав 18 или более 
небрежных строк кода, чтобы создать астероид. Создание астероида, перерисовка 
его на экран трудоемка для вашей системы. Когда вы возьмете более сложные 
объекты вы увидите, что я имел ввиду.
</p>

<p class="text">
Ну и какое решение? Списки Отображения!!! Используя список отображения, вы 
создаете объект лишь один раз. Вы можете текстурировать его, раскрасить его, все 
что хотите. Вы даете списку название. Поскольку это астероид мы назовем список 
'asteroid'. Теперь, всякий раз, когда я хочу нарисовать 
текстурированный/раскрашенный астероид на экране, все, что мне требуется сделать 
это вызов glCallList(asteroid). Предварительно созданный астероид немедленно 
появится на экране. Так как астероид уже создан в списке отображения, не нужно 
указывать OpenGL, как создать его. Он уже создан в памяти. Это снижает нагрузку 
на процессор и позволяет вашим программам выполняться быстрее.
</p>

<p class="text">
Итак, вы готовы учиться? :). Мы назовем эту демонстрацию списков отображения Q-
Bert. В этой демке мы создадим 15 кубиков на экране Q-Bert'а. Каждый кубик 
изготавливается из крышки (TOP) и коробки (BOX). Крышка будет отдельным списком 
отображения, так мы сможем закрасить ее в более темные цвета (как тень). Коробка 
- это куб без крышки :).
</p>

<p class="text">
Этот код основан на уроке 6. Я перепишу большую часть программы - так будет 
легче видеть, где я внес изменения. Следующие строки - код, стандартно 
используемый во всех уроках.
</p>

<p  ><font class="textpreword">#include &lt;windows.h&gt;      //Заголовочный файл для Windows<br>
#include &lt;stdio.h&gt;        //Заголовочный файл стандартного ввода/вывода<br>
#include &lt;gl\gl.h&gt;        //Заголовочный файл библиотеки OpenGL32<br>
#include &lt;gl\glu.h&gt;       //Заголовочный файл библиотеки GLu32<br>
#include &lt;gl\glaux.h&gt;     //Заголовочный файл библиотеки GLaux<br>
<br>
HDC             hDC=NULL;       //Приватный контекст GDI устройства<br>
<br>
HGLRC           hRC=NULL;       //Постоянный контекст отображения<br>
HWND            hWnd=NULL;      //Содержит дискриптор нашего окна<br>
HINSTANCE       hInstance;      //Содержит экземпляр приложения<br>
<br>
bool    keys[256];              //Массив применяемый для подпрограммы клавиатуры<br>
bool    active=TRUE;            //Флаг "Активное" окна устанавливается истинным (TRUE)<br>
                                // по умолчанию.<br>
bool    fullscreen=TRUE;        //Флаг "На полный экран" устанавливается в полноэкранный<br>
                                // режим по умолчанию.</font></p  >


<p class="text">
Теперь объявим наши переменные. Первым делом зарезервируем место для одной 
текстуры. Затем создадим две новых переменных для наших двух списков 
отображения. Эти переменные - указатели на списки отображения, хранящиеся в ОЗУ. 
Назовем их коробка (box) и крышка (top).
</p>

<p class="text">
Затем заведем еще 2 переменные xloop и yloop, которые используем для задания 
позиций кубов на экране и 2 переменные xrot и yrot для вращения по осям x и y.
</p>

<p  ><font class="textpreword">GLuint  texture[1];     // Память для одной текстуры<br>
GLuint  box;            // Память для списка отображения box (коробка)<br>
GLuint  top;            // Память для второго списка отображения top (крышка)<br>
GLuint  xloop;  // Цикл для оси x<br>
GLuint  yloop;  // Цикл для оси y<br>
<br>
GLfloat xrot;   // Вращает куб на оси x<br>
GLfloat yrot;   // Вращает куб на оси y</font></p  >

<p class="text">
Далее создаем два цветовых массива. Первый, назовем его boxcol, хранит величины 
для следующих цветов: ярко-красного (Bright Red), оранжевого (Orange), желтого 
(Yellow), зеленого (Green) и голубого (Blue). Каждое значение внутри фигурных 
скобок представляет значения красного, зеленого и голубого цветов. Каждая группа 
внутри фигурных скобок - конкретный цвет.
</p>

<p class="text">
Второй массив цветов мы создаем для следующих цветов: темно-красного (Dark Red), 
темно-оранжевого (Dark Orange), темно-желтого (Dark Yellow), темно-зеленого 
(Dark Green) и темно-голубого (Dark Blue). Темные цвета будем использовать для 
окрашивания крышки коробок. Мы хотим, чтобы крышка была темнее коробки.
</p>

<p  ><font class="textpreword">static GLfloat boxcol[5][3]=    //Массив для цветов коробки<br>
{<br>
<br>
//Яркие: Красный, Оранжевый, Желтый, Зеленый, Голубой<br>
{1.0f,0.0f,0.0f},{1.0f,0.5f,0.0f},{1.0f,1.0f,0.0f},{0.0f,1.0f,0.0f},{0.0f,1.0f,1.0f}<br>
};<br>
<br>
static GLfloat topcol[5][3]=    //Массив для цветов верха<br>
{<br>
//Темные: Красный, Оранжевый, Желтый, Зеленый, Голубой<br>
{.5f,0.0f,0.0f},{0.5f,0.25f,0.0f},{0.5f,0.5f,0.0f},{0.0f,0.5f,0.0f},{0.0f,0.5f,0.5f}<br>
};<br>
<br>
LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM); //Объявление для WndProc</font></p  >

<p class="text">
Теперь мы создадим собственно список отображения. Если вы помните, весь код для 
создания коробки в первом списке, а для создания верха - в другом списке. Я 
попытаюсь разъяснить эту часть более детально.
</p>

<p  ><font class="textpreword">GLvoid BuildLists()     //создаем список отображения<br>
{</font></p  >

<p class="text">
Мы начинаем, указывая OpenGL создать 2 списка. glGenLists(2) создает место для 
двух списков, и возвращает указатель на первый из них. 'box' будет хранить 
расположение первого списка. Всякий раз при вызове box будет нарисован первый 
список.
</p>

<p  ><font class="textpreword">box=glGenLists(2);      //создаем два списка</font></p  >

<p class="text">
Теперь мы начнем создавать первый список. Мы уже выделили память для двух 
списков, и мы знаем, что box указывает на место, где мы храним первый список. 
Все, что нам теперь надо сделать - это сказать OpenGL, где должен начаться 
список, какой тип списка сделать.
</p>

<p class="text">
Мы используем для этого команду glNewList(). Укажите box в качестве первого 
параметра. Этим вы укажете OpenGL место хранения списка, на которое указывает 
переменная box. Второй параметр GL_COMPILE говорит OpenGL, что мы хотим 
предварительно создать список в памяти, таким образом, OpenGL не будет 
вычислять, как создать объект, всякий раз как мы хотим нарисовать его.
</p>

<p class="text">
С флагом GL_COMPILE как в программирование. Если вы пишете программу и 
транслируете ее компилятором вы компилируете ее всякий раз, когда хотите 
запустить ее. Если же она уже скомпилирована в EXE файл, все, что вам нужно 
сделать - это запустить ее, кликнув на файле. Нет необходимости 
перекомпилировать ее заново. OpenGL компилирует список отображения только один 
раз, после этого он готов к применению, больше компилировать не надо. Поэтому мы 
получаем увеличение скорости при использовании списков отображения.
</p>

<p  ><font class="textpreword">glNewList(box,GL_COMPILE);      // Новый откомпилированный список отображения box</font></p  >

<p class="text">
В следующей части кода нарисуем коробку без верха. Она не окажется на экране. 
Она будет сохранена в списке отображения.
</p>

<p class="text">
Вы можете написать любую команду, какую только захотите, между glNewList() и 
glEndList(). Вы можете задавать цвета, менять текстуры и т.д. Единственный тип 
кода, который вы не можете использовать - это код, который изменит список 
отображения "на лету". Однажды создав список отображения, вы не можете его 
изменить.
</p>

<p class="text">
Если вы добавите строку glColor3ub(rand()%255,rand()%255,rand()%255) в 
нижеследующий код, вы можете подумать, что каждый раз, когда вы рисуете объект 
на экране, он будет другого цвета. Но так как список создается лишь однажды, 
цвет не будет изменяться всякий раз, как вы рисуете его на экране. Каким бы ни 
был цвет объекта, когда он создается первый раз, таким он и останется.
</p>

<p class="text">
Если вы хотите изменить цвет списка отображения, вам необходимо изменить его ДО 
того как список отображения будет выведен на экран. Я больше расскажу об этом 
позже.
</p>

<p  ><font class="textpreword">glBegin(GL_QUADS);      // Начинаем рисование четырехугольников (quads)<br>
                        // Нижняя поверхность<br>
glTexCoord2f(1.0f, 1.0f);<br>
glVertex3f(-1.0f, -1.0f, -1.0f);        // Верхний правый угол текстуры и четырехугольник<br>
glTexCoord2f(0.0f, 1.0f); <br>
glVertex3f( 1.0f, -1.0f, -1.0f);        // Верхний левый угол текстуры и четырехугольник<br>
glTexCoord2f(0.0f, 0.0f); <br>
glVertex3f( 1.0f, -1.0f,  1.0f);        // Нижний левый угол текстуры и четырехугольник<br>
glTexCoord2f(1.0f, 0.0f); <br>
glVertex3f(-1.0f, -1.0f,  1.0f);        // Нижний правый угол текстуры и четырехугольник<br>
                        // Передняя поверхность<br>
glTexCoord2f(0.0f, 0.0f); <br>
glVertex3f(-1.0f, -1.0f,  1.0f);        // Нижний левый угол текстуры и четырехугольник<br>
glTexCoord2f(1.0f, 0.0f); <br>
glVertex3f( 1.0f, -1.0f,  1.0f);        // Нижний правый угол текстуры и четырехугольник<br>
glTexCoord2f(1.0f, 1.0f); <br>
glVertex3f( 1.0f,  1.0f,  1.0f);        // Верхний правый угол текстуры и четырехугольник<br>
glTexCoord2f(0.0f, 1.0f); <br>
glVertex3f(-1.0f,  1.0f,  1.0f);        // Верхний левый угол текстуры и четырехугольник<br>
                        // Задняя поверхность<br>
glTexCoord2f(1.0f, 0.0f); <br>
glVertex3f(-1.0f, -1.0f, -1.0f);        // Нижний правый угол текстуры и четырехугольник<br>
glTexCoord2f(1.0f, 1.0f); <br>
glVertex3f(-1.0f,  1.0f, -1.0f);        // Верхний правый угол текстуры и четырехугольник<br>
glTexCoord2f(0.0f, 1.0f); <br>
glVertex3f( 1.0f,  1.0f, -1.0f);        // Верхний левый угол текстуры и четырехугольник<br>
glTexCoord2f(0.0f, 0.0f); <br>
glVertex3f( 1.0f, -1.0f, -1.0f);        // Нижний левый угол текстуры и четырехугольник<br>
                        // Правая поверхность<br>
glTexCoord2f(1.0f, 0.0f); <br>
glVertex3f( 1.0f, -1.0f, -1.0f);        // Нижний правый угол текстуры и четырехугольник<br>
glTexCoord2f(1.0f, 1.0f); <br>
glVertex3f( 1.0f,  1.0f, -1.0f);        // Верхний правый угол текстуры и четырехугольник<br>
glTexCoord2f(0.0f, 1.0f); <br>
glVertex3f( 1.0f,  1.0f,  1.0f);        // Верхний левый угол текстуры и четырехугольник<br>
glTexCoord2f(0.0f, 0.0f); <br>
glVertex3f( 1.0f, -1.0f,  1.0f);        // Нижний левый угол текстуры и четырехугольник<br>
                        // Левая поверхность<br>
glTexCoord2f(0.0f, 0.0f); <br>
glVertex3f(-1.0f, -1.0f, -1.0f);        // Нижний левый угол текстуры и четырехугольник<br>
glTexCoord2f(1.0f, 0.0f); <br>
glVertex3f(-1.0f, -1.0f,  1.0f);        // Нижний правый угол текстуры и четырехугольник<br>
glTexCoord2f(1.0f, 1.0f); <br>
glVertex3f(-1.0f,  1.0f,  1.0f);        // Верхний правый угол текстуры и четырехугольник<br>
glTexCoord2f(0.0f, 1.0f); <br>
glVertex3f(-1.0f,  1.0f, -1.0f);        // Верхний левый угол текстуры и четырехугольник<br>
glEnd();                        // Закончили рисование четырехугольников</font></p  >

<p class="text">
При помощи команды glEndList() мы сказали OpenGL, что мы создали список. Все, 
что находится между glNewList() и glEndList - часть списка отображения, все, что 
находится до glNewList() или после glEndList() не является частью списка 
отображения.
</p>


<p  ><font class="textpreword">glEndList(); // Закончили создание списка box</font></p  >

<p class="text">
Теперь создадим наш второй список отображения. Чтобы найти, где список 
отображения хранится в памяти, мы возьмем значение старого списка отображения 
(box) и добавим к нему еще единицу. Нижеследующий код присваивает переменной 
'top' местоположение второго списка отображения.
</p>

<p  ><font class="textpreword">top=box+1; // Значение top это значение box + 1</font></p  >

<p class="text">
Теперь, когда мы знаем, где хранится второй список отображения, мы можем создать 
его. Мы сделаем это, так же как и первый список, но в этот раз мы укажем OpenGL 
хранить этот список под названием 'top' в отличие от предыдущего 'box'.
</p>

<p  ><font class="textpreword">glNewList(top,GL_COMPILE);// Новый откомпилированный список отображения 'top'</font></p  >

<p class="text">
Следующая часть кода рисует верх коробки. Это просто четырехугольник 
нарисованный на плоскости z.
</p>

<p  ><font class="textpreword">glBegin(GL_QUADS);      // Начинаем рисование четырехугольника<br>
                        // Верхняя поверхность<br>
glTexCoord2f(0.0f, 1.0f); <br>
glVertex3f(-1.0f,  1.0f, -1.0f);        // Верхний левый угол текстуры и четырехугольник<br>
glTexCoord2f(0.0f, 0.0f); <br>
glVertex3f(-1.0f,  1.0f,  1.0f);        // Нижний левый угол текстуры и четырехугольник<br>
glTexCoord2f(1.0f, 0.0f); <br>
glVertex3f( 1.0f,  1.0f,  1.0f);        // Нижний правый угол текстуры и четырехугольник<br>
glTexCoord2f(1.0f, 1.0f); <br>
glVertex3f( 1.0f,  1.0f, -1.0f);        // Верхний правый угол текстуры и четырехугольник<br>
glEnd();                // Заканчиваем рисование четырехугольника</font></p  >

<p class="text">Снова говорим OpenGL, что мы закончили создание списка отображения с помощью 
команды glEndList(). Вот. Мы успешно создали два списка отображения.</p>
<p  ><font class="textpreword">        glEndList();            // Закончили создание списка отображения 'top'<br>
}</font></p  >

<p class="text">
Код создания текстур тот же, который мы использовали в предыдущих уроках для 
загрузки и создания текстур. Мы хотим получить текстуру, которую сможем наложить 
на все шесть сторон каждого куба. Я, бесспорно, буду использовать мипмаппинг, 
чтобы сделать действительно сглаженные текстуры. Я ненавижу глядеть на пиксели 
:). Текстура для загрузки называется 'cube.bmp'. Она хранится в каталоге под 
названием 'data'. Найдите LoadBMP и измените эту строку таким образом, чтобы она 
выглядела как нижеследующая строка.
</p>

<p  ><font class="textpreword">if (TextureImage[0]=LoadBMP("Data/Cube.bmp"))           // Загрузить картинку. </font></p  >

<p class="text">
Код изменения размеров такой же, как в Уроке N6.
</p>

<p class="text">
Только в коде инициализации есть несколько изменений. Я добавлю строку 
BuildList(). Это будет переход к части кода, в которой создаются списки 
отображения. Обратите внимание что BuildList() находится после LoagGLTextures(). 
Важно знать, что порядок должен быть именно таким. Сначала мы создаем текстуру, 
а затем создаем наши списки отображения, где уже созданные текстуру мы можем 
наложить на куб.
</p>

<p  ><font class="textpreword">int InitGL(GLvoid)// Все настройки OpenGL начинаются здесь<br>
{<br>
        if (!LoadGLTextures())// Переход к процедуре загрузки текстуры<br>
        {<br>
                return FALSE;// Если текстура не загружена возращает FALSE<br>
        }<br>
        BuildLists();// Переход к коду, который создает наши списки отображения<br>
        glEnable(GL_TEXTURE_2D);// Включение нанесения текстур<br>
        glShadeModel(GL_SMOOTH);// Включение гладкой закраски (smooth shading)<br>
        glClearColor(0.0f, 0.0f, 0.0f, 0.5f);// Черный фон<br>
        glClearDepth(1.0f);// Установка буфера глубины<br>
        glEnable(GL_DEPTH_TEST);// Включение проверки глубины<br>
        glDepthFunc(GL_LEQUAL); // Тип выполняемой проверки глубины</font></p  >

<p class="text">
Следующие три строки кода включают быстрое и простое освещение. Light0 
предустановлен на большинстве видеоплат, и это спасет нас от трудностей 
установки источников освещения. После того как мы включили light0, мы включили 
освещение. Если light0 не работает на вашей видео плате (вы видите темноту), 
просто отключите освещение.
</p>

<p class="text">
Еще одна строка GL_COLOR_MATERIAL позволяет нам добавить цвет к текстурам. Если 
мы, не включили закрашивание материала, текстуры всегда будут своего 
первоначального цвета. glColor3f(r,g,b) не будет действовать на расцвечивание. 
Поэтому важно включить это.
</p>

<p  ><font class="textpreword">glEnable(GL_LIGHT0); // Быстрое простое освещение<br>
                        // (устанавливает в качестве источника освещения Light0)<br>
glEnable(GL_LIGHTING);  // Включает освещение<br>
glEnable(GL_COLOR_MATERIAL);    // Включает раскрашивание материала</font></p  >

<p class="text">
Наконец, мы устанавливаем коррекцию перспективы для улучшения внешнего вида и 
возвращаем TRUE, давая знать нашей программе, что инициализация прошла OK.
</p>

<p  ><font class="textpreword">glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);      // Изящная коррекция перспективы<br>
return TRUE;                                            // Инициализация прошла OK<br>
}</font></p  >

<p class="text">
Теперь часть программы для рисования. Как обычно, я немного шизею с математики. 
Нет SIN и COS, но это все еще непривычно :). Мы начнем, как обычно, с очистки 
экрана и глубины буфера.
</p>

<p class="text">
Затем мы привяжем текстуру к кубу. Я мог добавить эту строку в коде списка 
отображения, но, оставляя ее вне списка, я могу изменить текстуру, когда захочу. 
Если бы я добавил строку glBindTexture(GL_TEXTURE_2D, texture[0]) внутри кода 
списка отображения, список был бы создан с этой текстурой постоянно нанесенной 
на него.
</p>

<p  ><font class="textpreword">int DrawGLScene(GLvoid)                 // Здесь мы выполняем все рисование<br>
{<br>
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);     // Очищаем экран и буфер глубины<br>
<br>
glBindTexture(GL_TEXTURE_2D, texture[0]);               // Выбираем текстуру</font></p  >

<p class="text">
Теперь немного позабавимся. Мы имеем цикл по yloop. Этот цикл используется для 
позиционирования кубов по оси Y (вверх и вниз). Мы хотим иметь 5 строк кубиков 
вверх и вниз, итак мы создадим цикл от 1 до 6 (то есть 5).
</p>
	
<p  ><font class="textpreword">        for (yloop=1;yloop<6;yloop++)                           // Цикл по плоскости Y<br>
        {</font></p  >

<p class="text">
Создадим другой цикл по xloop. Он используется для позиционирования кубиков по 
оси x (слева направо). Количество кубов зависит от того, в какой они рисуются 
строке. В верхней строчке xloop будет изменяться только от 0 до 1 (рисование 
одного кубика). В следующей строке xloop изменяется от 0 до 2 (рисование 2-х 
кубиков) и так далее.
</p>

<p  ><font class="textpreword">                for (xloop=0;xloop< yloop;xloop++)              // Цикл по плоскости X<br>
                {</font></p  >
   
<p class="text">
Мы очищаем наше окно с помощью glLoadIdentity(). 
</p>
<p  ><font class="textpreword">                        glLoadIdentity();                       // Очистка вида</font></p  >

<p class="text">
Следующая строка задает особую точку на экране. Это может сбить с толку, но не 
пугайтесь. На оси X происходит следующее:
</p>

<p class="text">
Мы смещаемся вправо на 1.4 единицы так, чтобы центр пирамиды оказался в центре 
экрана. Умножим xloop на 2.8 и добавим к ней 1.4 (мы умножаем на 2.8, так как 
кубики стоят друг на друге, 2.8 это приближенная ширина куба, когда он повернут 
на 45 градусов, по диагонали куба). Наконец, вычитаем yloop*1.4. Это перемещение 
кубов влево в зависимости от того, в какой строке он находится. Если мы не 
сместим влево, пирамида начнется у левого края экрана (не будет выглядеть как 
пирамида).
</p>

<p class="text">
На оси Y мы вычитаем yloop из 6, иначе пирамида будет нарисована сверху вниз. 
Результат умножим на 2.4. Иначе кубики будут находиться друг на друге. (2.4 
примерная высота куба). Затем мы отнимем 7, чтобы пирамида начиналась от низа 
экрана и строилась вверх.
</p>

<p class="text">
Наконец по оси Z мы переместимся на 20 единиц в глубь экрана. Так мы добьемся 
того, что бы пирамида хорошо вписалась в экран.
</p>

<p  ><font class="textpreword">                        // Размещение кубиков на экране<br>
glTranslatef(1.4f+(float(xloop)*2.8f)-(float(yloop)*1.4f),<br>
        ((6.0f-float(yloop))*2.4f)-7.0f,-20.0f);</font></p  >

<p class="text">
Теперь мы повернемся вокруг оси X. Таким образом, мы наклоним кубики вперед на 
45 градусов минус 2 умноженное на yloop. Режим перспективы наклоняет кубики 
автоматически, и я вычитаю, чтобы скомпенсировать наклон. Не лучший способ, но 
это работает.
</p>

<p class="text">
Наконец добавим xrot. Это дает нам управлять углом с клавиатуры. (Получите 
удовольствие, играя с ним).
</p>

<p class="text">
После этого повернем кубики на 45 градусов вокруг оси Y, и добавим yrot чтобы 
управлять с клавиатуры поворотом вокруг оси Y.
</p>

<p  ><font class="textpreword">glRotatef(45.0f-(2.0f*yloop)+xrot,1.0f,0.0f,0.0f);      // Наклонять кубы вверх и вниз<br>
glRotatef(45.0f+yrot,0.0f,1.0f,0.0f);                   // Вращать кубы вправо и влево</font></p  >

<p class="text">
Далее мы выберем цвет коробки (яркий) перед тем как действительно нарисовать эту 
часть куба. Мы используем команду glColor3fv(), которая выполняет загрузку всех 
трех значений цвета (красный, зеленый, голубой). Аббревиатура 3fv означает 3 
значения, числа с плавающей точкой, v указатель на массив. Цвет мы выбираем по 
переменной yloop-1, что дает нам разные цвета для каждого ряда кубов. Если мы 
используем xloop-1, мы получим различные цвета для каждого столбца.
</p>

<p  ><font class="textpreword">glColor3fv(boxcol[yloop-1]);            // Выбор цвета коробки </font></p  >

<p class="text">
Теперь, когда цвет установлен, все что надо сделать - нарисовать нашу коробку. В 
отличие от написания всего кода для рисования коробки, все, что нам нужно - 
вызвать наш список отображения. Мы сделаем это командой glCallList(box). box 
указывает OpenGL выбрать список отображения box. Список отображения box - это 
кубик без верха.
</p>

<p class="text">
Коробка будет нарисована цветом, выбранным командой glColor3fv(), в месте, куда 
мы ее передвинули.
</p>


<p  ><font class="textpreword">glCallList(box);                        // Рисуем коробку</font></p  >

<p class="text">
Теперь выберем цвет крышки (темный) перед тем как нарисовать крышку коробки. 
Если вы действительно хотите сделать Q-Bert, вы измените этот цвет всякий раз, 
когда Q-Bert вскакивает на коробку. Цвет устанавливается в зависимости от ряда.
</p>

<p  ><font class="textpreword">glColor3fv(topcol[yloop-1]);            // Выбор цвета верха</font></p  >

<p class="text">
Наконец, осталось нарисовать список отображения top. Этим мы добавим более 
темного цвета крышку. Все. Очень легко!
</p>

<p  ><font class="textpreword"><br>
                        glCallList(top);                        // Рисуем крышку<br>
                }<br>
        }<br>
        return TRUE;                                            // Возвращаемся обратно.<br>
<br>
}</font></p  >

<p class="text">
Все необходимые изменения будут выполнены в WinMain(). Код будет добавлен сразу 
после строки SwapBuffers(hDC). Этим кодом мы проверим нажатие кнопок "стрелка 
влево", "вправо", "вверх", "вниз" и соответственно повернем кубы.
</p>

<p  ><font class="textpreword">                SwapBuffers(hDC);       // Поменяем буферы (Двойная буферизация)<br>
                if (keys[VK_LEFT])      // Была нажата стрелка влево?<br>
                {<br>
                        yrot-=0.2f;     // Если так, то повернем кубы влево<br>
                }<br>
                if (keys[VK_RIGHT])     // Была нажата стрелка вправо?<br>
                {<br>
                        yrot+=0.2f;     // Если так, то повернем кубы вправо<br>
                }<br>
                if (keys[VK_UP])        // Была нажата стрелка вверх?<br>
                {<br>
                        xrot-=0.2f;     // Если так, то наклоним кубы вверх<br>
                }<br>
                if (keys[VK_DOWN])      // Была нажата стрелка вниз?<br>
                {<br>
                        xrot+=0.2f;     // Если так, то наклоним кубы вниз<br>
                }</font></p  >

<p class="text">
Как во всех предыдущих уроках, убедимся, что заголовок на верху окна правильный.
</p>

<p  ><font class="textpreword">                if (keys[VK_F1])                // Была нажата кнопка F1?<br>
                {<br>
                        keys[VK_F1]=FALSE;// Если так - установим значение FALSE<br>
                        KillGLWindow(); // Закроем текущее окно OpenGL<br>
                        // Переключим режим "Полный экран"/"Оконный"<br>
                        fullscreen=!fullscreen;<br>
                        // Заново создадим наше окно OpenGL<br>
                        if (!CreateGLWindow("NeHe's Display List Tutorial",<br>
                                640,480,16,fullscreen))<br>
                        {<br>
                                return 0;// Выйти, если окно не было создано<br>
                        }<br>
                }<br>
        }<br>
}</font></p  >

<p class="text">
В результате этого урока вы усвоили, как работает список отображения, как его 
создавать, и как выводить его на экран. Списки отображения восхитительны. Не 
только потому, что они упрощают программирование сложных проектов, они также 
дают небольшое увеличение необходимое для поддержания высокой частоты обновления 
экрана.
</p>

<p class="text">
Я надеюсь, вам понравился этот урок. Если у вас есть вопросы или вы чувствуете, 
что что-нибудь не ясно, пожалуйста, напишите мне и дайте мне знать.
</p>

<p class="textnoalign" align="right">
<font color="#0000A0"><b> © Jeff Molofee (NeHe)</b></font><br>
</p>          
</div>

<div id="end">
<p>
<a href="http://pmg-ru.narod.ru/"
onmouseover=" return event_over(this,'Программирование магических игр')  "
onmouseout=" return event_out(this) ">
<font class="link"><b>PMG</b></font></a>

<font class="comment">&nbsp;25 сентября 2001&nbsp;(c)&nbsp;</font>

<a href="mailto:okulov_alexey@mail.ru"
onmouseover=" return event_over(this,'Почта переводчику')  "
onmouseout=" return event_out(this) ">
<font class="link"><b>Alexey Okulov</b></font></a>
</p>
</div>

<div id="counter">
<script language="javascript">
d=document;rn=Math.random();
y="<a href='http://u013.94.spylog.com/cnt?f=3&rn="+rn+"' target=_blank><img src='http://u013.94.spylog.com/cnt?";
y+="p=1&f=4&rn="+rn+"' border=0 width=88 height=31 ></a>"; d.write(y);
</script><noscript>
<a href="http://u013.94.spylog.com/cnt?f=3&p=1" target=_blank>
<img src="http://u013.94.spylog.com/cnt?p=1&f=4" alt='SpyLog' border='0' width=88 height=31 ></a>
</noscript>
</div>
</center>

<script language="JavaScript">
<!--
form_print();
//-->
</script>

</body>
</html>